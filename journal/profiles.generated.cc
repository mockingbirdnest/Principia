// Warning!  This file was generated by running a program (see project |tools|).
// If you change it, the changes will be lost the next time the generator is
// run.  You should change the generator instead.

namespace {

NavigationFrameParameters DeserializeNavigationFrameParameters(serialization::NavigationFrameParameters const& navigation_frame_parameters) {
  return {navigation_frame_parameters.extension(),
          navigation_frame_parameters.centre_index(),
          navigation_frame_parameters.primary_index(),
          navigation_frame_parameters.secondary_index()};
}

XYZ DeserializeXYZ(serialization::XYZ const& xyz) {
  return {xyz.x(),
          xyz.y(),
          xyz.z()};
}

AdaptiveStepParameters DeserializeAdaptiveStepParameters(serialization::AdaptiveStepParameters const& adaptive_step_parameters) {
  return {adaptive_step_parameters.integrator_kind(),
          adaptive_step_parameters.max_steps(),
          adaptive_step_parameters.length_integration_tolerance(),
          adaptive_step_parameters.speed_integration_tolerance()};
}

BodyGeopotentialCoefficient DeserializeBodyGeopotentialCoefficient(serialization::BodyGeopotentialCoefficient const& body_geopotential_coefficient) {
  return {body_geopotential_coefficient.degree(),
          body_geopotential_coefficient.order(),
          body_geopotential_coefficient.value()};
}

BodyParameters DeserializeBodyParameters(serialization::BodyParameters const& body_parameters, std::vector<BodyGeopotentialCoefficient>& geopotential_cos_storage, std::vector<BodyGeopotentialCoefficient>& geopotential_sin_storage) {
  return {body_parameters.name().c_str(),
          body_parameters.gravitational_parameter().c_str(),
          body_parameters.has_reference_instant() ? body_parameters.reference_instant().c_str() : nullptr,
          body_parameters.has_mean_radius() ? body_parameters.mean_radius().c_str() : nullptr,
          body_parameters.has_axis_right_ascension() ? body_parameters.axis_right_ascension().c_str() : nullptr,
          body_parameters.has_axis_declination() ? body_parameters.axis_declination().c_str() : nullptr,
          body_parameters.has_reference_angle() ? body_parameters.reference_angle().c_str() : nullptr,
          body_parameters.has_angular_frequency() ? body_parameters.angular_frequency().c_str() : nullptr,
          body_parameters.has_j2() ? body_parameters.j2().c_str() : nullptr,
          body_parameters.has_reference_radius() ? body_parameters.reference_radius().c_str() : nullptr,
          [&geopotential_cos_storage](::google::protobuf::RepeatedPtrField<serialization::BodyGeopotentialCoefficient> const& messages) {
            for (auto const& message : messages) {
              geopotential_cos_storage.push_back(DeserializeBodyGeopotentialCoefficient(message));
            }
            return &geopotential_cos_storage[0];
          }(body_parameters.geopotential_cos()),
          body_parameters.geopotential_cos().size(),
          [&geopotential_sin_storage](::google::protobuf::RepeatedPtrField<serialization::BodyGeopotentialCoefficient> const& messages) {
            for (auto const& message : messages) {
              geopotential_sin_storage.push_back(DeserializeBodyGeopotentialCoefficient(message));
            }
            return &geopotential_sin_storage[0];
          }(body_parameters.geopotential_sin()),
          body_parameters.geopotential_sin().size()};
}

Burn DeserializeBurn(serialization::Burn const& burn) {
  return {burn.thrust_in_kilonewtons(),
          burn.specific_impulse_in_seconds_g0(),
          DeserializeNavigationFrameParameters(burn.frame()),
          burn.initial_time(),
          DeserializeXYZ(burn.delta_v()),
          burn.is_inertially_fixed()};
}

ConfigurationAccuracyParameters DeserializeConfigurationAccuracyParameters(serialization::ConfigurationAccuracyParameters const& configuration_accuracy_parameters) {
  return {configuration_accuracy_parameters.fitting_tolerance().c_str(),
          configuration_accuracy_parameters.geopotential_tolerance().c_str()};
}

ConfigurationFixedStepParameters DeserializeConfigurationFixedStepParameters(serialization::ConfigurationFixedStepParameters const& configuration_fixed_step_parameters) {
  return {configuration_fixed_step_parameters.fixed_step_size_integrator().c_str(),
          configuration_fixed_step_parameters.integration_step_size().c_str()};
}

ConfigurationAdaptiveStepParameters DeserializeConfigurationAdaptiveStepParameters(serialization::ConfigurationAdaptiveStepParameters const& configuration_adaptive_step_parameters) {
  return {configuration_adaptive_step_parameters.adaptive_step_size_integrator().c_str(),
          configuration_adaptive_step_parameters.length_integration_tolerance().c_str(),
          configuration_adaptive_step_parameters.speed_integration_tolerance().c_str()};
}

KeplerianElements DeserializeKeplerianElements(serialization::KeplerianElements const& keplerian_elements) {
  return {keplerian_elements.eccentricity(),
          keplerian_elements.semimajor_axis(),
          keplerian_elements.mean_motion(),
          keplerian_elements.inclination_in_degrees(),
          keplerian_elements.longitude_of_ascending_node_in_degrees(),
          keplerian_elements.argument_of_periapsis_in_degrees(),
          keplerian_elements.mean_anomaly()};
}

NavigationManoeuvre DeserializeNavigationManoeuvre(serialization::NavigationManoeuvre const& navigation_manoeuvre) {
  return {DeserializeBurn(navigation_manoeuvre.burn()),
          navigation_manoeuvre.initial_mass_in_tonnes(),
          navigation_manoeuvre.final_mass_in_tonnes(),
          navigation_manoeuvre.mass_flow(),
          navigation_manoeuvre.duration(),
          navigation_manoeuvre.final_time(),
          navigation_manoeuvre.time_of_half_delta_v(),
          navigation_manoeuvre.time_to_half_delta_v(),
          DeserializeXYZ(navigation_manoeuvre.inertial_direction())};
}

NavigationManoeuvreFrenetTrihedron DeserializeNavigationManoeuvreFrenetTrihedron(serialization::NavigationManoeuvreFrenetTrihedron const& navigation_manoeuvre_frenet_trihedron) {
  return {DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.binormal()),
          DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.normal()),
          DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.tangent())};
}

Origin DeserializeOrigin(serialization::Origin const& origin) {
  return {origin.reference_part_is_at_origin(),
          origin.reference_part_is_unmoving(),
          origin.reference_part_id(),
          DeserializeXYZ(origin.main_body_centre_in_world())};
}

QP DeserializeQP(serialization::QP const& qp) {
  return {DeserializeXYZ(qp.q()),
          DeserializeXYZ(qp.p())};
}

Status DeserializeStatus(serialization::Status const& status) {
  return {status.error()};
}

WXYZ DeserializeWXYZ(serialization::WXYZ const& wxyz) {
  return {wxyz.w(),
          wxyz.x(),
          wxyz.y(),
          wxyz.z()};
}

XY DeserializeXY(serialization::XY const& xy) {
  return {xy.x(),
          xy.y()};
}

serialization::NavigationFrameParameters SerializeNavigationFrameParameters(NavigationFrameParameters const& navigation_frame_parameters) {
  serialization::NavigationFrameParameters m;
  m.set_extension(navigation_frame_parameters.extension);
  m.set_centre_index(navigation_frame_parameters.centre_index);
  m.set_primary_index(navigation_frame_parameters.primary_index);
  m.set_secondary_index(navigation_frame_parameters.secondary_index);
  return m;
}

serialization::XYZ SerializeXYZ(XYZ const& xyz) {
  serialization::XYZ m;
  m.set_x(xyz.x);
  m.set_y(xyz.y);
  m.set_z(xyz.z);
  return m;
}

serialization::AdaptiveStepParameters SerializeAdaptiveStepParameters(AdaptiveStepParameters const& adaptive_step_parameters) {
  serialization::AdaptiveStepParameters m;
  m.set_integrator_kind(adaptive_step_parameters.integrator_kind);
  m.set_max_steps(adaptive_step_parameters.max_steps);
  m.set_length_integration_tolerance(adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::BodyGeopotentialCoefficient SerializeBodyGeopotentialCoefficient(BodyGeopotentialCoefficient const& body_geopotential_coefficient) {
  serialization::BodyGeopotentialCoefficient m;
  m.set_degree(body_geopotential_coefficient.degree);
  m.set_order(body_geopotential_coefficient.order);
  m.set_value(body_geopotential_coefficient.value);
  return m;
}

serialization::BodyParameters SerializeBodyParameters(BodyParameters const& body_parameters) {
  serialization::BodyParameters m;
  m.set_name(body_parameters.name);
  m.set_gravitational_parameter(body_parameters.gravitational_parameter);
  if (body_parameters.reference_instant != nullptr) {
    m.set_reference_instant(body_parameters.reference_instant);
  }
  if (body_parameters.mean_radius != nullptr) {
    m.set_mean_radius(body_parameters.mean_radius);
  }
  if (body_parameters.axis_right_ascension != nullptr) {
    m.set_axis_right_ascension(body_parameters.axis_right_ascension);
  }
  if (body_parameters.axis_declination != nullptr) {
    m.set_axis_declination(body_parameters.axis_declination);
  }
  if (body_parameters.reference_angle != nullptr) {
    m.set_reference_angle(body_parameters.reference_angle);
  }
  if (body_parameters.angular_frequency != nullptr) {
    m.set_angular_frequency(body_parameters.angular_frequency);
  }
  if (body_parameters.j2 != nullptr) {
    m.set_j2(body_parameters.j2);
  }
  if (body_parameters.reference_radius != nullptr) {
    m.set_reference_radius(body_parameters.reference_radius);
  }
  for (BodyGeopotentialCoefficient const* geopotential_cos = body_parameters.geopotential_cos; geopotential_cos < body_parameters.geopotential_cos + body_parameters.geopotential_cos_size; ++geopotential_cos) {
    *m.add_geopotential_cos() = SerializeBodyGeopotentialCoefficient(*geopotential_cos);
  }
  for (BodyGeopotentialCoefficient const* geopotential_sin = body_parameters.geopotential_sin; geopotential_sin < body_parameters.geopotential_sin + body_parameters.geopotential_sin_size; ++geopotential_sin) {
    *m.add_geopotential_sin() = SerializeBodyGeopotentialCoefficient(*geopotential_sin);
  }
  return m;
}

serialization::Burn SerializeBurn(Burn const& burn) {
  serialization::Burn m;
  m.set_thrust_in_kilonewtons(burn.thrust_in_kilonewtons);
  m.set_specific_impulse_in_seconds_g0(burn.specific_impulse_in_seconds_g0);
  *m.mutable_frame() = SerializeNavigationFrameParameters(burn.frame);
  m.set_initial_time(burn.initial_time);
  *m.mutable_delta_v() = SerializeXYZ(burn.delta_v);
  m.set_is_inertially_fixed(burn.is_inertially_fixed);
  return m;
}

serialization::ConfigurationAccuracyParameters SerializeConfigurationAccuracyParameters(ConfigurationAccuracyParameters const& configuration_accuracy_parameters) {
  serialization::ConfigurationAccuracyParameters m;
  m.set_fitting_tolerance(configuration_accuracy_parameters.fitting_tolerance);
  m.set_geopotential_tolerance(configuration_accuracy_parameters.geopotential_tolerance);
  return m;
}

serialization::ConfigurationFixedStepParameters SerializeConfigurationFixedStepParameters(ConfigurationFixedStepParameters const& configuration_fixed_step_parameters) {
  serialization::ConfigurationFixedStepParameters m;
  m.set_fixed_step_size_integrator(configuration_fixed_step_parameters.fixed_step_size_integrator);
  m.set_integration_step_size(configuration_fixed_step_parameters.integration_step_size);
  return m;
}

serialization::ConfigurationAdaptiveStepParameters SerializeConfigurationAdaptiveStepParameters(ConfigurationAdaptiveStepParameters const& configuration_adaptive_step_parameters) {
  serialization::ConfigurationAdaptiveStepParameters m;
  m.set_adaptive_step_size_integrator(configuration_adaptive_step_parameters.adaptive_step_size_integrator);
  m.set_length_integration_tolerance(configuration_adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(configuration_adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::KeplerianElements SerializeKeplerianElements(KeplerianElements const& keplerian_elements) {
  serialization::KeplerianElements m;
  m.set_eccentricity(keplerian_elements.eccentricity);
  m.set_semimajor_axis(keplerian_elements.semimajor_axis);
  m.set_mean_motion(keplerian_elements.mean_motion);
  m.set_inclination_in_degrees(keplerian_elements.inclination_in_degrees);
  m.set_longitude_of_ascending_node_in_degrees(keplerian_elements.longitude_of_ascending_node_in_degrees);
  m.set_argument_of_periapsis_in_degrees(keplerian_elements.argument_of_periapsis_in_degrees);
  m.set_mean_anomaly(keplerian_elements.mean_anomaly);
  return m;
}

serialization::NavigationManoeuvre SerializeNavigationManoeuvre(NavigationManoeuvre const& navigation_manoeuvre) {
  serialization::NavigationManoeuvre m;
  *m.mutable_burn() = SerializeBurn(navigation_manoeuvre.burn);
  m.set_initial_mass_in_tonnes(navigation_manoeuvre.initial_mass_in_tonnes);
  m.set_final_mass_in_tonnes(navigation_manoeuvre.final_mass_in_tonnes);
  m.set_mass_flow(navigation_manoeuvre.mass_flow);
  m.set_duration(navigation_manoeuvre.duration);
  m.set_final_time(navigation_manoeuvre.final_time);
  m.set_time_of_half_delta_v(navigation_manoeuvre.time_of_half_delta_v);
  m.set_time_to_half_delta_v(navigation_manoeuvre.time_to_half_delta_v);
  *m.mutable_inertial_direction() = SerializeXYZ(navigation_manoeuvre.inertial_direction);
  return m;
}

serialization::NavigationManoeuvreFrenetTrihedron SerializeNavigationManoeuvreFrenetTrihedron(NavigationManoeuvreFrenetTrihedron const& navigation_manoeuvre_frenet_trihedron) {
  serialization::NavigationManoeuvreFrenetTrihedron m;
  *m.mutable_binormal() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.binormal);
  *m.mutable_normal() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.normal);
  *m.mutable_tangent() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.tangent);
  return m;
}

serialization::Origin SerializeOrigin(Origin const& origin) {
  serialization::Origin m;
  m.set_reference_part_is_at_origin(origin.reference_part_is_at_origin);
  m.set_reference_part_is_unmoving(origin.reference_part_is_unmoving);
  m.set_reference_part_id(origin.reference_part_id);
  *m.mutable_main_body_centre_in_world() = SerializeXYZ(origin.main_body_centre_in_world);
  return m;
}

serialization::QP SerializeQP(QP const& qp) {
  serialization::QP m;
  *m.mutable_q() = SerializeXYZ(qp.q);
  *m.mutable_p() = SerializeXYZ(qp.p);
  return m;
}

serialization::Status SerializeStatus(Status const& status) {
  serialization::Status m;
  m.set_error(status.error);
  return m;
}

serialization::WXYZ SerializeWXYZ(WXYZ const& wxyz) {
  serialization::WXYZ m;
  m.set_w(wxyz.w);
  m.set_x(wxyz.x);
  m.set_y(wxyz.y);
  m.set_z(wxyz.z);
  return m;
}

serialization::XY SerializeXY(XY const& xy) {
  serialization::XY m;
  m.set_x(xy.x);
  m.set_y(xy.y);
  return m;
}

}  // namespace

void AdvanceTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
  m->set_planetarium_rotation(in.planetarium_rotation);
}

void AdvanceTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto t = in.t();
  auto planetarium_rotation = in.planetarium_rotation();
  interface::principia__AdvanceTime(plugin, t, planetarium_rotation);
}

void CatchUpLaggingVessels::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CatchUpLaggingVessels::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_collided_vessels(SerializePointer(*out.collided_vessels));
}

void CatchUpLaggingVessels::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto const& out = message.out();
  Iterator* collided_vessels;
  interface::principia__CatchUpLaggingVessels(plugin, &collided_vessels);
  Insert(pointer_map, out.collided_vessels(), collided_vessels);
}

void CelestialFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialFromParent::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialFromParent(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void CelestialInitialRotationInDegrees::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialInitialRotationInDegrees::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CelestialInitialRotationInDegrees::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialInitialRotationInDegrees(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CelestialRotation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void CelestialRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CelestialRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto index = in.index();
  auto const result = interface::principia__CelestialRotation(plugin, index);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void CelestialRotationPeriod::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialRotationPeriod::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CelestialRotationPeriod::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialRotationPeriod(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CelestialSphereRotation::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CelestialSphereRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CelestialSphereRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto const result = interface::principia__CelestialSphereRotation(plugin);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void CelestialWorldDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
  *m->mutable_origin() = SerializeOrigin(in.origin);
  m->set_time(in.time);
}

void CelestialWorldDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialWorldDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto index = in.index();
  auto origin = DeserializeOrigin(in.origin());
  auto time = in.time();
  auto const result = interface::principia__CelestialWorldDegreesOfFreedom(plugin, index, origin, time);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void ClearTargetVessel::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void ClearTargetVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__ClearTargetVessel(plugin);
}

void ClearWorldRotationalReferenceFrame::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void ClearWorldRotationalReferenceFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__ClearWorldRotationalReferenceFrame(plugin);
}

void CurrentTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CurrentTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CurrentTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto const result = interface::principia__CurrentTime(plugin);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void DeletePlugin::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(*in.plugin));
}

void DeletePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_plugin(SerializePointer(*out.plugin));
}

void DeletePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto const& out = message.out();
  interface::principia__DeletePlugin(&plugin);
  Delete(pointer_map, in.plugin());
}

void DeleteString::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_string(SerializePointer(*in.native_string));
}

void DeleteString::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_string(SerializePointer(*out.native_string));
}

void DeleteString::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto native_string = DeserializePointer<char const*>(pointer_map, in.native_string());
  auto const& out = message.out();
  interface::principia__DeleteString(&native_string);
  Delete(pointer_map, in.native_string());
}

void DeleteU16String::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_string(SerializePointer(*in.native_string));
}

void DeleteU16String::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_string(SerializePointer(*out.native_string));
}

void DeleteU16String::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto native_string = DeserializePointer<char16_t const*>(pointer_map, in.native_string());
  auto const& out = message.out();
  interface::principia__DeleteU16String(&native_string);
  Delete(pointer_map, in.native_string());
}

void DeserializePluginHexadecimal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_serialization(std::string(in.serialization, in.serialization_size));
  m->set_deserializer(SerializePointer(*in.deserializer));
  m->set_plugin(SerializePointer(*in.plugin));
  if (in.compressor != nullptr) {
    m->set_compressor(in.compressor);
  }
}

void DeserializePluginHexadecimal::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_deserializer(SerializePointer(*out.deserializer));
  m->set_plugin(SerializePointer(*out.plugin));
}

void DeserializePluginHexadecimal::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto serialization = &in.serialization();
  auto deserializer = DeserializePointer<PushDeserializer*>(pointer_map, in.deserializer());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto compressor = in.has_compressor() ? in.compressor().c_str() : nullptr;
  auto const& out = message.out();
  interface::principia__DeserializePluginHexadecimal(serialization->c_str(), serialization->size(), &deserializer, &plugin, compressor);
  if (serialization->empty()) {
    Delete(pointer_map, in.deserializer());
  }
  if (!serialization->empty()) {
    Insert(pointer_map, out.deserializer(), deserializer);
  }
  Insert(pointer_map, out.plugin(), plugin);
}

void EndInitialization::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void EndInitialization::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__EndInitialization(plugin);
}

void ExternalFlowFreefall::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_central_body_index(in.central_body_index);
  *m->mutable_world_body_centred_initial_degrees_of_freedom() = SerializeQP(in.world_body_centred_initial_degrees_of_freedom);
  m->set_t_initial(in.t_initial);
  m->set_t_final(in.t_final);
}

void ExternalFlowFreefall::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_world_body_centred_final_degrees_of_freedom() = SerializeQP(*out.world_body_centred_final_degrees_of_freedom);
}

void ExternalFlowFreefall::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void ExternalFlowFreefall::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto central_body_index = in.central_body_index();
  auto world_body_centred_initial_degrees_of_freedom = DeserializeQP(in.world_body_centred_initial_degrees_of_freedom());
  auto t_initial = in.t_initial();
  auto t_final = in.t_final();
  auto const& out = message.out();
  QP world_body_centred_final_degrees_of_freedom;
  auto const result = interface::principia__ExternalFlowFreefall(plugin, central_body_index, world_body_centred_initial_degrees_of_freedom, t_initial, t_final, &world_body_centred_final_degrees_of_freedom);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_central_body_index(in.central_body_index);
  m->set_vessel_guid(in.vessel_guid);
  m->set_manoeuvre_index(in.manoeuvre_index);
  *m->mutable_world_body_centred_reference_position() = SerializeXYZ(in.world_body_centred_reference_position);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_world_body_centred_nearest_degrees_of_freedom() = SerializeQP(*out.world_body_centred_nearest_degrees_of_freedom);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto central_body_index = in.central_body_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto manoeuvre_index = in.manoeuvre_index();
  auto world_body_centred_reference_position = DeserializeXYZ(in.world_body_centred_reference_position());
  auto const& out = message.out();
  QP world_body_centred_nearest_degrees_of_freedom;
  auto const result = interface::principia__ExternalGetNearestPlannedCoastDegreesOfFreedom(plugin, central_body_index, vessel_guid, manoeuvre_index, world_body_centred_reference_position, &world_body_centred_nearest_degrees_of_freedom);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void FlightPlanAppend::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
}

void FlightPlanAppend::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanAppend::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn());
  auto const result = interface::principia__FlightPlanAppend(plugin, vessel_guid, burn);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
}

void FlightPlanCreate::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto mass_in_tonnes = in.mass_in_tonnes();
  interface::principia__FlightPlanCreate(plugin, vessel_guid, final_time, mass_in_tonnes);
}

void FlightPlanDelete::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanDelete(plugin, vessel_guid);
}

void FlightPlanExists::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanExists::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanExists::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanExists(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeAdaptiveStepParameters(result);
}

void FlightPlanGetAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetAdaptiveStepParameters(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeAdaptiveStepParameters(message.return_().result()), result);
}

void FlightPlanGetActualFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetActualFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetActualFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetActualFinalTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetDesiredFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetDesiredFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetDesiredFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetDesiredFinalTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetGuidance::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetGuidance::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void FlightPlanGetGuidance::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetGuidance(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void FlightPlanGetInitialTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetInitialTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetInitialTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetInitialTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetManoeuvre::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvre::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvre(result);
}

void FlightPlanGetManoeuvre::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvre(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeNavigationManoeuvre(message.return_().result()), result);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvreFrenetTrihedron(result);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvreFrenetTrihedron(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeNavigationManoeuvreFrenetTrihedron(message.return_().result()), result);
}

void FlightPlanNumberOfManoeuvres::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfManoeuvres::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfManoeuvres::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfManoeuvres(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanNumberOfSegments::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfSegments::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfSegments::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfSegments(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanRemoveLast::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanRemoveLast::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanRemoveLast(plugin, vessel_guid);
}

void FlightPlanRenderedApsides::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void FlightPlanRenderedApsides::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_apoapsides(SerializePointer(*out.apoapsides));
  m->set_periapsides(SerializePointer(*out.periapsides));
}

void FlightPlanRenderedApsides::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const& out = message.out();
  Iterator* apoapsides;
  Iterator* periapsides;
  interface::principia__FlightPlanRenderedApsides(plugin, vessel_guid, celestial_index, sun_world_position, &apoapsides, &periapsides);
  Insert(pointer_map, out.apoapsides(), apoapsides);
  Insert(pointer_map, out.periapsides(), periapsides);
}

void FlightPlanRenderedClosestApproaches::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void FlightPlanRenderedClosestApproaches::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_closest_approaches(SerializePointer(*out.closest_approaches));
}

void FlightPlanRenderedClosestApproaches::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const& out = message.out();
  Iterator* closest_approaches;
  interface::principia__FlightPlanRenderedClosestApproaches(plugin, vessel_guid, sun_world_position, &closest_approaches);
  Insert(pointer_map, out.closest_approaches(), closest_approaches);
}

void FlightPlanRenderedNodes::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void FlightPlanRenderedNodes::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_ascending(SerializePointer(*out.ascending));
  m->set_descending(SerializePointer(*out.descending));
}

void FlightPlanRenderedNodes::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const& out = message.out();
  Iterator* ascending;
  Iterator* descending;
  interface::principia__FlightPlanRenderedNodes(plugin, vessel_guid, sun_world_position, &ascending, &descending);
  Insert(pointer_map, out.ascending(), ascending);
  Insert(pointer_map, out.descending(), descending);
}

void FlightPlanRenderedSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_index(in.index);
}

void FlightPlanRenderedSegment::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FlightPlanRenderedSegment::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto index = in.index();
  auto const result = interface::principia__FlightPlanRenderedSegment(plugin, vessel_guid, sun_world_position, index);
  Insert(pointer_map, message.return_().result(), result);
}

void FlightPlanReplaceLast::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
}

void FlightPlanReplaceLast::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanReplaceLast::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn());
  auto const result = interface::principia__FlightPlanReplaceLast(plugin, vessel_guid, burn);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanSetAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(in.adaptive_step_parameters);
}

void FlightPlanSetAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanSetAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto adaptive_step_parameters = DeserializeAdaptiveStepParameters(in.adaptive_step_parameters());
  auto const result = interface::principia__FlightPlanSetAdaptiveStepParameters(plugin, vessel_guid, adaptive_step_parameters);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanSetDesiredFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
}

void FlightPlanSetDesiredFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanSetDesiredFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto const result = interface::principia__FlightPlanSetDesiredFinalTime(plugin, vessel_guid, final_time);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void ForgetAllHistoriesBefore::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
}

void ForgetAllHistoriesBefore::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto t = in.t();
  interface::principia__ForgetAllHistoriesBefore(plugin, t);
}

void FreeVesselsAndPartsAndCollectPileUps::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_delta_t(in.delta_t);
}

void FreeVesselsAndPartsAndCollectPileUps::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto delta_t = in.delta_t();
  interface::principia__FreeVesselsAndPartsAndCollectPileUps(plugin, delta_t);
}

void FutureCatchUpVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FutureCatchUpVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FutureCatchUpVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FutureCatchUpVessel(plugin, vessel_guid);
  Insert(pointer_map, message.return_().result(), result);
}

void FutureWaitForVesselToCatchUp::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_future(SerializePointer(*in.future));
}

void FutureWaitForVesselToCatchUp::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_future(SerializePointer(*out.future));
  m->set_collided_vessels(SerializePointer(*out.collided_vessels));
}

void FutureWaitForVesselToCatchUp::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto future = DeserializePointer<PileUpFuture*>(pointer_map, in.future());
  auto const& out = message.out();
  Iterator* collided_vessels;
  interface::principia__FutureWaitForVesselToCatchUp(plugin, &future, &collided_vessels);
  Delete(pointer_map, in.future());
  Insert(pointer_map, out.collided_vessels(), collided_vessels);
}

void GetBufferDuration::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferDuration::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetBufferDuration();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetBufferedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetBufferedLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetPartActualDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_origin() = SerializeOrigin(in.origin);
}

void GetPartActualDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void GetPartActualDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto origin = DeserializeOrigin(in.origin());
  auto const result = interface::principia__GetPartActualDegreesOfFreedom(plugin, part_id, origin);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void GetStderrLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetStderrLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetStderrLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetSuppressedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetSuppressedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetSuppressedLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetVerboseLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetVerboseLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetVerboseLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetVersion::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_build_date(*out.build_date);
  m->set_version(*out.version);
}

void GetVersion::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& out = message.out();
  char const* build_date;
  char const* version;
  interface::principia__GetVersion(&build_date, &version);
}

void HasEncounteredApocalypse::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void HasEncounteredApocalypse::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_details(SerializePointer(*out.details));
}

void HasEncounteredApocalypse::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasEncounteredApocalypse::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto const& out = message.out();
  char const* details;
  auto const result = interface::principia__HasEncounteredApocalypse(plugin, &details);
  Insert(pointer_map, out.details(), details);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void HasVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void HasVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__HasVessel(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IncrementPartIntrinsicForce::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_force_in_kilonewtons() = SerializeXYZ(in.force_in_kilonewtons);
}

void IncrementPartIntrinsicForce::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto force_in_kilonewtons = DeserializeXYZ(in.force_in_kilonewtons());
  interface::principia__IncrementPartIntrinsicForce(plugin, part_id, force_in_kilonewtons);
}

void InitializeEphemerisParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_accuracy_parameters() = SerializeConfigurationAccuracyParameters(in.accuracy_parameters);
  *m->mutable_fixed_step_parameters() = SerializeConfigurationFixedStepParameters(in.fixed_step_parameters);
}

void InitializeEphemerisParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto accuracy_parameters = DeserializeConfigurationAccuracyParameters(in.accuracy_parameters());
  auto fixed_step_parameters = DeserializeConfigurationFixedStepParameters(in.fixed_step_parameters());
  interface::principia__InitializeEphemerisParameters(plugin, accuracy_parameters, fixed_step_parameters);
}

void InitializeHistoryParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeConfigurationFixedStepParameters(in.parameters);
}

void InitializeHistoryParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto parameters = DeserializeConfigurationFixedStepParameters(in.parameters());
  interface::principia__InitializeHistoryParameters(plugin, parameters);
}

void InitializePsychohistoryParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeConfigurationAdaptiveStepParameters(in.parameters);
}

void InitializePsychohistoryParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto parameters = DeserializeConfigurationAdaptiveStepParameters(in.parameters());
  interface::principia__InitializePsychohistoryParameters(plugin, parameters);
}

void InsertCelestialAbsoluteCartesian::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  *m->mutable_body_parameters() = SerializeBodyParameters(in.body_parameters);
  m->set_x(in.x);
  m->set_y(in.y);
  m->set_z(in.z);
  m->set_vx(in.vx);
  m->set_vy(in.vy);
  m->set_vz(in.vz);
}

void InsertCelestialAbsoluteCartesian::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.has_parent_index() ? std::make_unique<int const>(in.parent_index()) : nullptr;
  std::vector<BodyGeopotentialCoefficient> geopotential_cos_storage;
  std::vector<BodyGeopotentialCoefficient> geopotential_sin_storage;
  auto body_parameters = DeserializeBodyParameters(in.body_parameters(), geopotential_cos_storage, geopotential_sin_storage);
  auto x = in.x().c_str();
  auto y = in.y().c_str();
  auto z = in.z().c_str();
  auto vx = in.vx().c_str();
  auto vy = in.vy().c_str();
  auto vz = in.vz().c_str();
  interface::principia__InsertCelestialAbsoluteCartesian(plugin, celestial_index, parent_index.get(), body_parameters, x, y, z, vx, vy, vz);
}

void InsertCelestialJacobiKeplerian::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  *m->mutable_body_parameters() = SerializeBodyParameters(in.body_parameters);
  if (in.keplerian_elements != nullptr) {
    *m->mutable_keplerian_elements() = SerializeKeplerianElements(*in.keplerian_elements);
  }
}

void InsertCelestialJacobiKeplerian::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.has_parent_index() ? std::make_unique<int const>(in.parent_index()) : nullptr;
  std::vector<BodyGeopotentialCoefficient> geopotential_cos_storage;
  std::vector<BodyGeopotentialCoefficient> geopotential_sin_storage;
  auto body_parameters = DeserializeBodyParameters(in.body_parameters(), geopotential_cos_storage, geopotential_sin_storage);
  auto keplerian_elements = in.has_keplerian_elements() ? std::make_unique<KeplerianElements const>(DeserializeKeplerianElements(in.keplerian_elements())) : nullptr;
  interface::principia__InsertCelestialJacobiKeplerian(plugin, celestial_index, parent_index.get(), body_parameters, keplerian_elements.get());
}

void InsertOrKeepVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_vessel_name(in.vessel_name);
  m->set_parent_index(in.parent_index);
  m->set_loaded(in.loaded);
}

void InsertOrKeepVessel::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_inserted(*out.inserted);
}

void InsertOrKeepVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto vessel_name = in.vessel_name().c_str();
  auto parent_index = in.parent_index();
  auto loaded = in.loaded();
  auto const& out = message.out();
  bool inserted;
  interface::principia__InsertOrKeepVessel(plugin, vessel_guid, vessel_name, parent_index, loaded, &inserted);
}

void InsertOrKeepLoadedPart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  m->set_name(in.name);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
  m->set_vessel_guid(in.vessel_guid);
  m->set_main_body_index(in.main_body_index);
  *m->mutable_main_body_world_degrees_of_freedom() = SerializeQP(in.main_body_world_degrees_of_freedom);
  *m->mutable_part_world_degrees_of_freedom() = SerializeQP(in.part_world_degrees_of_freedom);
  m->set_delta_t(in.delta_t);
}

void InsertOrKeepLoadedPart::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto name = in.name().c_str();
  auto mass_in_tonnes = in.mass_in_tonnes();
  auto vessel_guid = in.vessel_guid().c_str();
  auto main_body_index = in.main_body_index();
  auto main_body_world_degrees_of_freedom = DeserializeQP(in.main_body_world_degrees_of_freedom());
  auto part_world_degrees_of_freedom = DeserializeQP(in.part_world_degrees_of_freedom());
  auto delta_t = in.delta_t();
  interface::principia__InsertOrKeepLoadedPart(plugin, part_id, name, mass_in_tonnes, vessel_guid, main_body_index, main_body_world_degrees_of_freedom, part_world_degrees_of_freedom, delta_t);
}

void InsertUnloadedPart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  m->set_name(in.name);
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_from_parent() = SerializeQP(in.from_parent);
}

void InsertUnloadedPart::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto name = in.name().c_str();
  auto vessel_guid = in.vessel_guid().c_str();
  auto from_parent = DeserializeQP(in.from_parent());
  interface::principia__InsertUnloadedPart(plugin, part_id, name, vessel_guid, from_parent);
}

void IteratorAtEnd::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorAtEnd::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorAtEnd::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorAtEnd(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IteratorDelete::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(*in.iterator));
}

void IteratorDelete::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_iterator(SerializePointer(*out.iterator));
}

void IteratorDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(pointer_map, in.iterator());
  auto const& out = message.out();
  interface::principia__IteratorDelete(&iterator);
  Delete(pointer_map, in.iterator());
}

void IteratorGetDiscreteTrajectoryQP::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryQP::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void IteratorGetDiscreteTrajectoryQP::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryQP(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void IteratorGetDiscreteTrajectoryTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorGetDiscreteTrajectoryTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryTime(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IteratorGetDiscreteTrajectoryXYZ::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryXYZ::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void IteratorGetDiscreteTrajectoryXYZ::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryXYZ(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void IteratorGetRP2LinesIterator::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetRP2LinesIterator::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void IteratorGetRP2LinesIterator::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetRP2LinesIterator(iterator);
  Insert(pointer_map, message.return_().result(), result);
}

void IteratorGetRP2LineXY::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetRP2LineXY::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXY(result);
}

void IteratorGetRP2LineXY::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetRP2LineXY(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeXY(message.return_().result()), result);
}

void IteratorGetVesselGuid::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetVesselGuid::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorGetVesselGuid::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetVesselGuid(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result().c_str(), result);
}

void IteratorIncrement::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorIncrement::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(pointer_map, in.iterator());
  interface::principia__IteratorIncrement(iterator);
}

void IteratorReset::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorReset::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(pointer_map, in.iterator());
  interface::principia__IteratorReset(iterator);
}

void IteratorSize::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorSize::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorSize::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorSize(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void LogError::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogError::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogError(text);
}

void LogFatal::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogFatal::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogFatal(text);
}

void LogInfo::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogInfo::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogInfo(text);
}

void LogWarning::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogWarning::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogWarning(text);
}

void MonitorSetName::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_i(in.i);
  m->set_name(in.name);
}

void MonitorSetName::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto i = in.i();
  auto name = in.name().c_str();
  interface::principia__MonitorSetName(i, name);
}

void MonitorStart::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_i(in.i);
}

void MonitorStart::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto i = in.i();
  interface::principia__MonitorStart(i);
}

void MonitorStop::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_i(in.i);
}

void MonitorStop::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto i = in.i();
  interface::principia__MonitorStop(i);
}

void NavballOrientation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_ship_world_position() = SerializeXYZ(in.ship_world_position);
}

void NavballOrientation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void NavballOrientation::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto ship_world_position = DeserializeXYZ(in.ship_world_position());
  auto const result = interface::principia__NavballOrientation(plugin, sun_world_position, ship_world_position);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void NewNavigationFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeNavigationFrameParameters(in.parameters);
}

void NewNavigationFrame::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewNavigationFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto parameters = DeserializeNavigationFrameParameters(in.parameters());
  auto const result = interface::principia__NewNavigationFrame(plugin, parameters);
  Insert(pointer_map, message.return_().result(), result);
}

void NewPlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_game_epoch(in.game_epoch);
  m->set_solar_system_epoch(in.solar_system_epoch);
  m->set_planetarium_rotation_in_degrees(in.planetarium_rotation_in_degrees);
}

void NewPlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewPlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto game_epoch = in.game_epoch().c_str();
  auto solar_system_epoch = in.solar_system_epoch().c_str();
  auto planetarium_rotation_in_degrees = in.planetarium_rotation_in_degrees();
  auto const result = interface::principia__NewPlugin(game_epoch, solar_system_epoch, planetarium_rotation_in_degrees);
  Insert(pointer_map, message.return_().result(), result);
}

void PlanetariumCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_xyz_opengl_camera_x_in_world() = SerializeXYZ(in.xyz_opengl_camera_x_in_world);
  *m->mutable_xyz_opengl_camera_y_in_world() = SerializeXYZ(in.xyz_opengl_camera_y_in_world);
  *m->mutable_xyz_opengl_camera_z_in_world() = SerializeXYZ(in.xyz_opengl_camera_z_in_world);
  *m->mutable_xyz_camera_position_in_world() = SerializeXYZ(in.xyz_camera_position_in_world);
  m->set_focal(in.focal);
  m->set_field_of_view(in.field_of_view);
}

void PlanetariumCreate::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void PlanetariumCreate::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto xyz_opengl_camera_x_in_world = DeserializeXYZ(in.xyz_opengl_camera_x_in_world());
  auto xyz_opengl_camera_y_in_world = DeserializeXYZ(in.xyz_opengl_camera_y_in_world());
  auto xyz_opengl_camera_z_in_world = DeserializeXYZ(in.xyz_opengl_camera_z_in_world());
  auto xyz_camera_position_in_world = DeserializeXYZ(in.xyz_camera_position_in_world());
  auto focal = in.focal();
  auto field_of_view = in.field_of_view();
  auto const result = interface::principia__PlanetariumCreate(plugin, sun_world_position, xyz_opengl_camera_x_in_world, xyz_opengl_camera_y_in_world, xyz_opengl_camera_z_in_world, xyz_camera_position_in_world, focal, field_of_view);
  Insert(pointer_map, message.return_().result(), result);
}

void PlanetariumDelete::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_planetarium(SerializePointer(*in.planetarium));
}

void PlanetariumDelete::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_planetarium(SerializePointer(*out.planetarium));
}

void PlanetariumDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto const& out = message.out();
  interface::principia__PlanetariumDelete(&planetarium);
  Delete(pointer_map, in.planetarium());
}

void PlanetariumPlotFlightPlanSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_method(in.method);
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void PlanetariumPlotFlightPlanSegment::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotFlightPlanSegment::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto method = in.method();
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__PlanetariumPlotFlightPlanSegment(planetarium, plugin, method, vessel_guid, index);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PlanetariumPlotPrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_method(in.method);
  m->set_vessel_guid(in.vessel_guid);
}

void PlanetariumPlotPrediction::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotPrediction::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto method = in.method();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__PlanetariumPlotPrediction(planetarium, plugin, method, vessel_guid);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PlanetariumPlotPsychohistory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_method(in.method);
  m->set_vessel_guid(in.vessel_guid);
}

void PlanetariumPlotPsychohistory::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotPsychohistory::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto method = in.method();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__PlanetariumPlotPsychohistory(planetarium, plugin, method, vessel_guid);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PrepareToReportCollisions::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void PrepareToReportCollisions::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__PrepareToReportCollisions(plugin);
}

void RenderedPredictionApsides::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void RenderedPredictionApsides::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_apoapsides(SerializePointer(*out.apoapsides));
  m->set_periapsides(SerializePointer(*out.periapsides));
}

void RenderedPredictionApsides::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const& out = message.out();
  Iterator* apoapsides;
  Iterator* periapsides;
  interface::principia__RenderedPredictionApsides(plugin, vessel_guid, celestial_index, sun_world_position, &apoapsides, &periapsides);
  Insert(pointer_map, out.apoapsides(), apoapsides);
  Insert(pointer_map, out.periapsides(), periapsides);
}

void RenderedPredictionClosestApproaches::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void RenderedPredictionClosestApproaches::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_closest_approaches(SerializePointer(*out.closest_approaches));
}

void RenderedPredictionClosestApproaches::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const& out = message.out();
  Iterator* closest_approaches;
  interface::principia__RenderedPredictionClosestApproaches(plugin, vessel_guid, sun_world_position, &closest_approaches);
  Insert(pointer_map, out.closest_approaches(), closest_approaches);
}

void RenderedPredictionNodes::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void RenderedPredictionNodes::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_ascending(SerializePointer(*out.ascending));
  m->set_descending(SerializePointer(*out.descending));
}

void RenderedPredictionNodes::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const& out = message.out();
  Iterator* ascending;
  Iterator* descending;
  interface::principia__RenderedPredictionNodes(plugin, vessel_guid, sun_world_position, &ascending, &descending);
  Insert(pointer_map, out.ascending(), ascending);
  Insert(pointer_map, out.descending(), descending);
}

void ReportGroundCollision::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
}

void ReportGroundCollision::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  interface::principia__ReportGroundCollision(plugin, part_id);
}

void ReportPartCollision::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part1_id(in.part1_id);
  m->set_part2_id(in.part2_id);
}

void ReportPartCollision::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part1_id = in.part1_id();
  auto part2_id = in.part2_id();
  interface::principia__ReportPartCollision(plugin, part1_id, part2_id);
}

void SayHello::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void SayHello::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__SayHello();
  PRINCIPIA_CHECK_EQ(message.return_().result().c_str(), result);
}

void SerializePluginHexadecimal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_serializer(SerializePointer(*in.serializer));
  if (in.compressor != nullptr) {
    m->set_compressor(in.compressor);
  }
}

void SerializePluginHexadecimal::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_serializer(SerializePointer(*out.serializer));
}

void SerializePluginHexadecimal::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void SerializePluginHexadecimal::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto serializer = DeserializePointer<PullSerializer*>(pointer_map, in.serializer());
  auto compressor = in.has_compressor() ? in.compressor().c_str() : nullptr;
  auto const& out = message.out();
  auto const result = interface::principia__SerializePluginHexadecimal(plugin, &serializer, compressor);
  if (result == nullptr) {
    Delete(pointer_map, in.serializer());
  }
  if (result != nullptr) {
    Insert(pointer_map, out.serializer(), serializer);
  }
  if (result != nullptr) {
    Insert(pointer_map, message.return_().result(), result);
  }
}

void SetBufferDuration::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_seconds(in.seconds);
}

void SetBufferDuration::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto seconds = in.seconds();
  interface::principia__SetBufferDuration(seconds);
}

void SetBufferedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_max_severity(in.max_severity);
}

void SetBufferedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto max_severity = in.max_severity();
  interface::principia__SetBufferedLogging(max_severity);
}

void SetMainBody::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void SetMainBody::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto index = in.index();
  interface::principia__SetMainBody(plugin, index);
}

void SetPartApparentDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_degrees_of_freedom() = SerializeQP(in.degrees_of_freedom);
  *m->mutable_main_body_degrees_of_freedom() = SerializeQP(in.main_body_degrees_of_freedom);
}

void SetPartApparentDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto degrees_of_freedom = DeserializeQP(in.degrees_of_freedom());
  auto main_body_degrees_of_freedom = DeserializeQP(in.main_body_degrees_of_freedom());
  interface::principia__SetPartApparentDegreesOfFreedom(plugin, part_id, degrees_of_freedom, main_body_degrees_of_freedom);
}

void SetPlottingFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_navigation_frame(SerializePointer(*in.navigation_frame));
}

void SetPlottingFrame::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_navigation_frame(SerializePointer(*out.navigation_frame));
}

void SetPlottingFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto navigation_frame = DeserializePointer<NavigationFrame*>(pointer_map, in.navigation_frame());
  auto const& out = message.out();
  interface::principia__SetPlottingFrame(plugin, &navigation_frame);
  Delete(pointer_map, in.navigation_frame());
}

void SetStderrLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetStderrLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetStderrLogging(min_severity);
}

void SetSuppressedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetSuppressedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetSuppressedLogging(min_severity);
}

void SetTargetVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_reference_body_index(in.reference_body_index);
}

void SetTargetVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto reference_body_index = in.reference_body_index();
  interface::principia__SetTargetVessel(plugin, vessel_guid, reference_body_index);
}

void SetVerboseLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_level(in.level);
}

void SetVerboseLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto level = in.level();
#if PRINCIPIA_SET_VERBOSE_LOGGING
  interface::principia__SetVerboseLogging(level);
#endif
}

void SetWorldRotationalReferenceFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void SetWorldRotationalReferenceFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto index = in.index();
  interface::principia__SetWorldRotationalReferenceFrame(plugin, index);
}

void UnmanageableVesselVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_degrees_of_freedom() = SerializeQP(in.degrees_of_freedom);
  m->set_celestial_index(in.celestial_index);
}

void UnmanageableVesselVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void UnmanageableVesselVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto degrees_of_freedom = DeserializeQP(in.degrees_of_freedom());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__UnmanageableVesselVelocity(plugin, degrees_of_freedom, celestial_index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void UpdateCelestialHierarchy::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_parent_index(in.parent_index);
}

void UpdateCelestialHierarchy::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.parent_index();
  interface::principia__UpdateCelestialHierarchy(plugin, celestial_index, parent_index);
}

void UpdatePrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void UpdatePrediction::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__UpdatePrediction(plugin, vessel_guid);
}

void VesselBinormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselBinormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselBinormal::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselBinormal(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void VesselFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_parent_index(in.parent_index);
  m->set_vessel_guid(in.vessel_guid);
}

void VesselFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void VesselFromParent::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto parent_index = in.parent_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselFromParent(plugin, parent_index, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void VesselGetPredictionAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselGetPredictionAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(result);
}

void VesselGetPredictionAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselGetPredictionAdaptiveStepParameters(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeAdaptiveStepParameters(message.return_().adaptive_step_parameters()), result);
}

void VesselNormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselNormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselNormal::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselNormal(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void VesselSetPredictionAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(in.adaptive_step_parameters);
}

void VesselSetPredictionAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto adaptive_step_parameters = DeserializeAdaptiveStepParameters(in.adaptive_step_parameters());
  interface::principia__VesselSetPredictionAdaptiveStepParameters(plugin, vessel_guid, adaptive_step_parameters);
}

void VesselTangent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselTangent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselTangent::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselTangent(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void VesselVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselVelocity(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

