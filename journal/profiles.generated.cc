// Warning!  This file was generated by running a program (see project |tools|).
// If you change it, the changes will be lost the next time the generator is
// run.  You should change the generator instead.

namespace {

NavigationFrameParameters DeserializeNavigationFrameParameters(serialization::NavigationFrameParameters const& navigation_frame_parameters) {
  return {navigation_frame_parameters.extension(),
          navigation_frame_parameters.centre_index(),
          navigation_frame_parameters.primary_index(),
          navigation_frame_parameters.secondary_index()};
}

XYZ DeserializeXYZ(serialization::XYZ const& xyz) {
  return {xyz.x(),
          xyz.y(),
          xyz.z()};
}

AdaptiveStepParameters DeserializeAdaptiveStepParameters(serialization::AdaptiveStepParameters const& adaptive_step_parameters) {
  return {adaptive_step_parameters.integrator_kind(),
          adaptive_step_parameters.max_steps(),
          adaptive_step_parameters.length_integration_tolerance(),
          adaptive_step_parameters.speed_integration_tolerance()};
}

BodyGeopotentialElement DeserializeBodyGeopotentialElement(serialization::BodyGeopotentialElement const& body_geopotential_element) {
  return {body_geopotential_element.degree().c_str(),
          body_geopotential_element.order().c_str(),
          body_geopotential_element.has_cos() ? body_geopotential_element.cos().c_str() : nullptr,
          body_geopotential_element.has_j() ? body_geopotential_element.j().c_str() : nullptr,
          body_geopotential_element.sin().c_str()};
}

BodyParameters DeserializeBodyParameters(serialization::BodyParameters const& body_parameters, std::vector<BodyGeopotentialElement>& geopotential_storage) {
  return {body_parameters.name().c_str(),
          body_parameters.gravitational_parameter().c_str(),
          body_parameters.has_reference_instant() ? body_parameters.reference_instant().c_str() : nullptr,
          body_parameters.has_min_radius() ? body_parameters.min_radius().c_str() : nullptr,
          body_parameters.has_mean_radius() ? body_parameters.mean_radius().c_str() : nullptr,
          body_parameters.has_max_radius() ? body_parameters.max_radius().c_str() : nullptr,
          body_parameters.has_axis_right_ascension() ? body_parameters.axis_right_ascension().c_str() : nullptr,
          body_parameters.has_axis_declination() ? body_parameters.axis_declination().c_str() : nullptr,
          body_parameters.has_reference_angle() ? body_parameters.reference_angle().c_str() : nullptr,
          body_parameters.has_angular_frequency() ? body_parameters.angular_frequency().c_str() : nullptr,
          body_parameters.has_reference_radius() ? body_parameters.reference_radius().c_str() : nullptr,
          body_parameters.has_j2() ? body_parameters.j2().c_str() : nullptr,
          [&geopotential_storage](::google::protobuf::RepeatedPtrField<serialization::BodyGeopotentialElement> const& messages) {
            for (auto const& message : messages) {
              geopotential_storage.push_back(DeserializeBodyGeopotentialElement(message));
            }
            return &geopotential_storage[0];
          }(body_parameters.geopotential()),
          body_parameters.geopotential().size()};
}

Burn DeserializeBurn(serialization::Burn const& burn) {
  return {burn.thrust_in_kilonewtons(),
          burn.specific_impulse_in_seconds_g0(),
          DeserializeNavigationFrameParameters(burn.frame()),
          burn.initial_time(),
          DeserializeXYZ(burn.delta_v()),
          burn.is_inertially_fixed()};
}

ConfigurationAccuracyParameters DeserializeConfigurationAccuracyParameters(serialization::ConfigurationAccuracyParameters const& configuration_accuracy_parameters) {
  return {configuration_accuracy_parameters.fitting_tolerance().c_str(),
          configuration_accuracy_parameters.geopotential_tolerance().c_str()};
}

ConfigurationFixedStepParameters DeserializeConfigurationFixedStepParameters(serialization::ConfigurationFixedStepParameters const& configuration_fixed_step_parameters) {
  return {configuration_fixed_step_parameters.fixed_step_size_integrator().c_str(),
          configuration_fixed_step_parameters.integration_step_size().c_str()};
}

ConfigurationAdaptiveStepParameters DeserializeConfigurationAdaptiveStepParameters(serialization::ConfigurationAdaptiveStepParameters const& configuration_adaptive_step_parameters) {
  return {configuration_adaptive_step_parameters.adaptive_step_size_integrator().c_str(),
          configuration_adaptive_step_parameters.length_integration_tolerance().c_str(),
          configuration_adaptive_step_parameters.speed_integration_tolerance().c_str()};
}

FlightPlanAdaptiveStepParameters DeserializeFlightPlanAdaptiveStepParameters(serialization::FlightPlanAdaptiveStepParameters const& flight_plan_adaptive_step_parameters) {
  return {flight_plan_adaptive_step_parameters.integrator_kind(),
          flight_plan_adaptive_step_parameters.generalized_integrator_kind(),
          flight_plan_adaptive_step_parameters.max_steps(),
          flight_plan_adaptive_step_parameters.length_integration_tolerance(),
          flight_plan_adaptive_step_parameters.speed_integration_tolerance()};
}

KeplerianElements DeserializeKeplerianElements(serialization::KeplerianElements const& keplerian_elements) {
  return {keplerian_elements.eccentricity(),
          keplerian_elements.semimajor_axis(),
          keplerian_elements.mean_motion(),
          keplerian_elements.inclination_in_degrees(),
          keplerian_elements.longitude_of_ascending_node_in_degrees(),
          keplerian_elements.argument_of_periapsis_in_degrees(),
          keplerian_elements.mean_anomaly()};
}

NavigationManoeuvre DeserializeNavigationManoeuvre(serialization::NavigationManoeuvre const& navigation_manoeuvre) {
  return {DeserializeBurn(navigation_manoeuvre.burn()),
          navigation_manoeuvre.initial_mass_in_tonnes(),
          navigation_manoeuvre.final_mass_in_tonnes(),
          navigation_manoeuvre.mass_flow(),
          navigation_manoeuvre.duration(),
          navigation_manoeuvre.final_time(),
          navigation_manoeuvre.time_of_half_delta_v(),
          navigation_manoeuvre.time_to_half_delta_v()};
}

NavigationManoeuvreFrenetTrihedron DeserializeNavigationManoeuvreFrenetTrihedron(serialization::NavigationManoeuvreFrenetTrihedron const& navigation_manoeuvre_frenet_trihedron) {
  return {DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.binormal()),
          DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.normal()),
          DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.tangent())};
}

Origin DeserializeOrigin(serialization::Origin const& origin) {
  return {origin.reference_part_is_at_origin(),
          origin.reference_part_is_unmoving(),
          origin.reference_part_id(),
          DeserializeXYZ(origin.main_body_centre_in_world())};
}

QP DeserializeQP(serialization::QP const& qp) {
  return {DeserializeXYZ(qp.q()),
          DeserializeXYZ(qp.p())};
}

Status DeserializeStatus(serialization::Status const& status) {
  return {status.error()};
}

WXYZ DeserializeWXYZ(serialization::WXYZ const& wxyz) {
  return {wxyz.w(),
          wxyz.x(),
          wxyz.y(),
          wxyz.z()};
}

QPRW DeserializeQPRW(serialization::QPRW const& qprw) {
  return {DeserializeQP(qprw.qp()),
          DeserializeWXYZ(qprw.r()),
          DeserializeXYZ(qprw.w())};
}

XY DeserializeXY(serialization::XY const& xy) {
  return {xy.x(),
          xy.y()};
}

Interval DeserializeInterval(serialization::Interval const& interval) {
  return {interval.min(),
          interval.max()};
}

OrbitalElements DeserializeOrbitalElements(serialization::OrbitalElements const& orbital_elements) {
  return {orbital_elements.sidereal_period(),
          orbital_elements.nodal_period(),
          orbital_elements.anomalistic_period(),
          orbital_elements.nodal_precession(),
          DeserializeInterval(orbital_elements.mean_semimajor_axis()),
          DeserializeInterval(orbital_elements.mean_eccentricity()),
          DeserializeInterval(orbital_elements.mean_inclination()),
          DeserializeInterval(orbital_elements.mean_longitude_of_ascending_nodes()),
          DeserializeInterval(orbital_elements.mean_argument_of_periapsis())};
}

OrbitRecurrence DeserializeOrbitRecurrence(serialization::OrbitRecurrence const& orbit_recurrence) {
  return {orbit_recurrence.nuo(),
          orbit_recurrence.dto(),
          orbit_recurrence.cto(),
          orbit_recurrence.number_of_revolutions(),
          orbit_recurrence.equatorial_shift(),
          orbit_recurrence.base_interval(),
          orbit_recurrence.grid_interval(),
          orbit_recurrence.subcycle()};
}

EquatorialCrossings DeserializeEquatorialCrossings(serialization::EquatorialCrossings const& equatorial_crossings) {
  return {DeserializeInterval(equatorial_crossings.longitudes_reduced_to_ascending_pass()),
          DeserializeInterval(equatorial_crossings.longitudes_reduced_to_descending_pass())};
}

OrbitGroundTrack DeserializeOrbitGroundTrack(serialization::OrbitGroundTrack const& orbit_ground_track) {
  return {DeserializeEquatorialCrossings(orbit_ground_track.equatorial_crossings())};
}

OrbitAnalysis DeserializeOrbitAnalysis(serialization::OrbitAnalysis const& orbit_analysis) {
  return {orbit_analysis.progress_of_next_analysis(),
          orbit_analysis.primary_index(),
          orbit_analysis.mission_duration(),
          DeserializeOrbitalElements(orbit_analysis.elements()),
          orbit_analysis.elements_has_value(),
          DeserializeOrbitRecurrence(orbit_analysis.recurrence()),
          orbit_analysis.recurrence_has_value(),
          DeserializeOrbitGroundTrack(orbit_analysis.ground_track()),
          orbit_analysis.ground_track_has_value()};
}

serialization::NavigationFrameParameters SerializeNavigationFrameParameters(NavigationFrameParameters const& navigation_frame_parameters) {
  serialization::NavigationFrameParameters m;
  m.set_extension(navigation_frame_parameters.extension);
  m.set_centre_index(navigation_frame_parameters.centre_index);
  m.set_primary_index(navigation_frame_parameters.primary_index);
  m.set_secondary_index(navigation_frame_parameters.secondary_index);
  return m;
}

serialization::XYZ SerializeXYZ(XYZ const& xyz) {
  serialization::XYZ m;
  m.set_x(xyz.x);
  m.set_y(xyz.y);
  m.set_z(xyz.z);
  return m;
}

serialization::AdaptiveStepParameters SerializeAdaptiveStepParameters(AdaptiveStepParameters const& adaptive_step_parameters) {
  serialization::AdaptiveStepParameters m;
  m.set_integrator_kind(adaptive_step_parameters.integrator_kind);
  m.set_max_steps(adaptive_step_parameters.max_steps);
  m.set_length_integration_tolerance(adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::BodyGeopotentialElement SerializeBodyGeopotentialElement(BodyGeopotentialElement const& body_geopotential_element) {
  serialization::BodyGeopotentialElement m;
  m.set_degree(body_geopotential_element.degree);
  m.set_order(body_geopotential_element.order);
  if (body_geopotential_element.cos != nullptr) {
    m.set_cos(body_geopotential_element.cos);
  }
  if (body_geopotential_element.j != nullptr) {
    m.set_j(body_geopotential_element.j);
  }
  m.set_sin(body_geopotential_element.sin);
  return m;
}

serialization::BodyParameters SerializeBodyParameters(BodyParameters const& body_parameters) {
  serialization::BodyParameters m;
  m.set_name(body_parameters.name);
  m.set_gravitational_parameter(body_parameters.gravitational_parameter);
  if (body_parameters.reference_instant != nullptr) {
    m.set_reference_instant(body_parameters.reference_instant);
  }
  if (body_parameters.min_radius != nullptr) {
    m.set_min_radius(body_parameters.min_radius);
  }
  if (body_parameters.mean_radius != nullptr) {
    m.set_mean_radius(body_parameters.mean_radius);
  }
  if (body_parameters.max_radius != nullptr) {
    m.set_max_radius(body_parameters.max_radius);
  }
  if (body_parameters.axis_right_ascension != nullptr) {
    m.set_axis_right_ascension(body_parameters.axis_right_ascension);
  }
  if (body_parameters.axis_declination != nullptr) {
    m.set_axis_declination(body_parameters.axis_declination);
  }
  if (body_parameters.reference_angle != nullptr) {
    m.set_reference_angle(body_parameters.reference_angle);
  }
  if (body_parameters.angular_frequency != nullptr) {
    m.set_angular_frequency(body_parameters.angular_frequency);
  }
  if (body_parameters.reference_radius != nullptr) {
    m.set_reference_radius(body_parameters.reference_radius);
  }
  if (body_parameters.j2 != nullptr) {
    m.set_j2(body_parameters.j2);
  }
  for (BodyGeopotentialElement const* geopotential = body_parameters.geopotential; geopotential < body_parameters.geopotential + body_parameters.geopotential_size; ++geopotential) {
    *m.add_geopotential() = SerializeBodyGeopotentialElement(*geopotential);
  }
  return m;
}

serialization::Burn SerializeBurn(Burn const& burn) {
  serialization::Burn m;
  m.set_thrust_in_kilonewtons(burn.thrust_in_kilonewtons);
  m.set_specific_impulse_in_seconds_g0(burn.specific_impulse_in_seconds_g0);
  *m.mutable_frame() = SerializeNavigationFrameParameters(burn.frame);
  m.set_initial_time(burn.initial_time);
  *m.mutable_delta_v() = SerializeXYZ(burn.delta_v);
  m.set_is_inertially_fixed(burn.is_inertially_fixed);
  return m;
}

serialization::ConfigurationAccuracyParameters SerializeConfigurationAccuracyParameters(ConfigurationAccuracyParameters const& configuration_accuracy_parameters) {
  serialization::ConfigurationAccuracyParameters m;
  m.set_fitting_tolerance(configuration_accuracy_parameters.fitting_tolerance);
  m.set_geopotential_tolerance(configuration_accuracy_parameters.geopotential_tolerance);
  return m;
}

serialization::ConfigurationFixedStepParameters SerializeConfigurationFixedStepParameters(ConfigurationFixedStepParameters const& configuration_fixed_step_parameters) {
  serialization::ConfigurationFixedStepParameters m;
  m.set_fixed_step_size_integrator(configuration_fixed_step_parameters.fixed_step_size_integrator);
  m.set_integration_step_size(configuration_fixed_step_parameters.integration_step_size);
  return m;
}

serialization::ConfigurationAdaptiveStepParameters SerializeConfigurationAdaptiveStepParameters(ConfigurationAdaptiveStepParameters const& configuration_adaptive_step_parameters) {
  serialization::ConfigurationAdaptiveStepParameters m;
  m.set_adaptive_step_size_integrator(configuration_adaptive_step_parameters.adaptive_step_size_integrator);
  m.set_length_integration_tolerance(configuration_adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(configuration_adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::FlightPlanAdaptiveStepParameters SerializeFlightPlanAdaptiveStepParameters(FlightPlanAdaptiveStepParameters const& flight_plan_adaptive_step_parameters) {
  serialization::FlightPlanAdaptiveStepParameters m;
  m.set_integrator_kind(flight_plan_adaptive_step_parameters.integrator_kind);
  m.set_generalized_integrator_kind(flight_plan_adaptive_step_parameters.generalized_integrator_kind);
  m.set_max_steps(flight_plan_adaptive_step_parameters.max_steps);
  m.set_length_integration_tolerance(flight_plan_adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(flight_plan_adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::KeplerianElements SerializeKeplerianElements(KeplerianElements const& keplerian_elements) {
  serialization::KeplerianElements m;
  m.set_eccentricity(keplerian_elements.eccentricity);
  m.set_semimajor_axis(keplerian_elements.semimajor_axis);
  m.set_mean_motion(keplerian_elements.mean_motion);
  m.set_inclination_in_degrees(keplerian_elements.inclination_in_degrees);
  m.set_longitude_of_ascending_node_in_degrees(keplerian_elements.longitude_of_ascending_node_in_degrees);
  m.set_argument_of_periapsis_in_degrees(keplerian_elements.argument_of_periapsis_in_degrees);
  m.set_mean_anomaly(keplerian_elements.mean_anomaly);
  return m;
}

serialization::NavigationManoeuvre SerializeNavigationManoeuvre(NavigationManoeuvre const& navigation_manoeuvre) {
  serialization::NavigationManoeuvre m;
  *m.mutable_burn() = SerializeBurn(navigation_manoeuvre.burn);
  m.set_initial_mass_in_tonnes(navigation_manoeuvre.initial_mass_in_tonnes);
  m.set_final_mass_in_tonnes(navigation_manoeuvre.final_mass_in_tonnes);
  m.set_mass_flow(navigation_manoeuvre.mass_flow);
  m.set_duration(navigation_manoeuvre.duration);
  m.set_final_time(navigation_manoeuvre.final_time);
  m.set_time_of_half_delta_v(navigation_manoeuvre.time_of_half_delta_v);
  m.set_time_to_half_delta_v(navigation_manoeuvre.time_to_half_delta_v);
  return m;
}

serialization::NavigationManoeuvreFrenetTrihedron SerializeNavigationManoeuvreFrenetTrihedron(NavigationManoeuvreFrenetTrihedron const& navigation_manoeuvre_frenet_trihedron) {
  serialization::NavigationManoeuvreFrenetTrihedron m;
  *m.mutable_binormal() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.binormal);
  *m.mutable_normal() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.normal);
  *m.mutable_tangent() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.tangent);
  return m;
}

serialization::Origin SerializeOrigin(Origin const& origin) {
  serialization::Origin m;
  m.set_reference_part_is_at_origin(origin.reference_part_is_at_origin);
  m.set_reference_part_is_unmoving(origin.reference_part_is_unmoving);
  m.set_reference_part_id(origin.reference_part_id);
  *m.mutable_main_body_centre_in_world() = SerializeXYZ(origin.main_body_centre_in_world);
  return m;
}

serialization::QP SerializeQP(QP const& qp) {
  serialization::QP m;
  *m.mutable_q() = SerializeXYZ(qp.q);
  *m.mutable_p() = SerializeXYZ(qp.p);
  return m;
}

serialization::Status SerializeStatus(Status const& status) {
  serialization::Status m;
  m.set_error(status.error);
  return m;
}

serialization::WXYZ SerializeWXYZ(WXYZ const& wxyz) {
  serialization::WXYZ m;
  m.set_w(wxyz.w);
  m.set_x(wxyz.x);
  m.set_y(wxyz.y);
  m.set_z(wxyz.z);
  return m;
}

serialization::QPRW SerializeQPRW(QPRW const& qprw) {
  serialization::QPRW m;
  *m.mutable_qp() = SerializeQP(qprw.qp);
  *m.mutable_r() = SerializeWXYZ(qprw.r);
  *m.mutable_w() = SerializeXYZ(qprw.w);
  return m;
}

serialization::XY SerializeXY(XY const& xy) {
  serialization::XY m;
  m.set_x(xy.x);
  m.set_y(xy.y);
  return m;
}

serialization::Interval SerializeInterval(Interval const& interval) {
  serialization::Interval m;
  m.set_min(interval.min);
  m.set_max(interval.max);
  return m;
}

serialization::OrbitalElements SerializeOrbitalElements(OrbitalElements const& orbital_elements) {
  serialization::OrbitalElements m;
  m.set_sidereal_period(orbital_elements.sidereal_period);
  m.set_nodal_period(orbital_elements.nodal_period);
  m.set_anomalistic_period(orbital_elements.anomalistic_period);
  m.set_nodal_precession(orbital_elements.nodal_precession);
  *m.mutable_mean_semimajor_axis() = SerializeInterval(orbital_elements.mean_semimajor_axis);
  *m.mutable_mean_eccentricity() = SerializeInterval(orbital_elements.mean_eccentricity);
  *m.mutable_mean_inclination() = SerializeInterval(orbital_elements.mean_inclination);
  *m.mutable_mean_longitude_of_ascending_nodes() = SerializeInterval(orbital_elements.mean_longitude_of_ascending_nodes);
  *m.mutable_mean_argument_of_periapsis() = SerializeInterval(orbital_elements.mean_argument_of_periapsis);
  return m;
}

serialization::OrbitRecurrence SerializeOrbitRecurrence(OrbitRecurrence const& orbit_recurrence) {
  serialization::OrbitRecurrence m;
  m.set_nuo(orbit_recurrence.nuo);
  m.set_dto(orbit_recurrence.dto);
  m.set_cto(orbit_recurrence.cto);
  m.set_number_of_revolutions(orbit_recurrence.number_of_revolutions);
  m.set_equatorial_shift(orbit_recurrence.equatorial_shift);
  m.set_base_interval(orbit_recurrence.base_interval);
  m.set_grid_interval(orbit_recurrence.grid_interval);
  m.set_subcycle(orbit_recurrence.subcycle);
  return m;
}

serialization::EquatorialCrossings SerializeEquatorialCrossings(EquatorialCrossings const& equatorial_crossings) {
  serialization::EquatorialCrossings m;
  *m.mutable_longitudes_reduced_to_ascending_pass() = SerializeInterval(equatorial_crossings.longitudes_reduced_to_ascending_pass);
  *m.mutable_longitudes_reduced_to_descending_pass() = SerializeInterval(equatorial_crossings.longitudes_reduced_to_descending_pass);
  return m;
}

serialization::OrbitGroundTrack SerializeOrbitGroundTrack(OrbitGroundTrack const& orbit_ground_track) {
  serialization::OrbitGroundTrack m;
  *m.mutable_equatorial_crossings() = SerializeEquatorialCrossings(orbit_ground_track.equatorial_crossings);
  return m;
}

serialization::OrbitAnalysis SerializeOrbitAnalysis(OrbitAnalysis const& orbit_analysis) {
  serialization::OrbitAnalysis m;
  m.set_progress_of_next_analysis(orbit_analysis.progress_of_next_analysis);
  m.set_primary_index(orbit_analysis.primary_index);
  m.set_mission_duration(orbit_analysis.mission_duration);
  *m.mutable_elements() = SerializeOrbitalElements(orbit_analysis.elements);
  m.set_elements_has_value(orbit_analysis.elements_has_value);
  *m.mutable_recurrence() = SerializeOrbitRecurrence(orbit_analysis.recurrence);
  m.set_recurrence_has_value(orbit_analysis.recurrence_has_value);
  *m.mutable_ground_track() = SerializeOrbitGroundTrack(orbit_analysis.ground_track);
  m.set_ground_track_has_value(orbit_analysis.ground_track_has_value);
  return m;
}

}  // namespace

void AdvanceTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
  m->set_planetarium_rotation(in.planetarium_rotation);
}

void AdvanceTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto t = in.t();
  auto planetarium_rotation = in.planetarium_rotation();
  interface::principia__AdvanceTime(plugin, t, planetarium_rotation);
}

void CameraReferenceRotation::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CameraReferenceRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CameraReferenceRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto const result = interface::principia__CameraReferenceRotation(plugin);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void CatchUpLaggingVessels::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CatchUpLaggingVessels::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_collided_vessels(SerializePointer(*out.collided_vessels));
}

void CatchUpLaggingVessels::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  [[maybe_unused]] auto const& out = message.out();
  Iterator* collided_vessels;
  interface::principia__CatchUpLaggingVessels(plugin, &collided_vessels);
  Insert(pointer_map, out.collided_vessels(), collided_vessels);
}

void CelestialFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialFromParent::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialFromParent(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void CelestialInitialRotationInDegrees::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialInitialRotationInDegrees::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CelestialInitialRotationInDegrees::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialInitialRotationInDegrees(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CelestialRotation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void CelestialRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CelestialRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto index = in.index();
  auto const result = interface::principia__CelestialRotation(plugin, index);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void CelestialRotationPeriod::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialRotationPeriod::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CelestialRotationPeriod::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialRotationPeriod(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CelestialSphereRotation::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CelestialSphereRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CelestialSphereRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto const result = interface::principia__CelestialSphereRotation(plugin);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void CelestialWorldDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
  *m->mutable_origin() = SerializeOrigin(in.origin);
  m->set_time(in.time);
}

void CelestialWorldDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialWorldDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto index = in.index();
  auto origin = DeserializeOrigin(in.origin());
  auto time = in.time();
  auto const result = interface::principia__CelestialWorldDegreesOfFreedom(plugin, index, origin, time);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void ClearFlags::Run(Message const& message, Player::PointerMap& pointer_map) {
  interface::principia__ClearFlags();
}

void ClearTargetVessel::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void ClearTargetVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__ClearTargetVessel(plugin);
}

void ClearWorldRotationalReferenceFrame::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void ClearWorldRotationalReferenceFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__ClearWorldRotationalReferenceFrame(plugin);
}

void CurrentTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CurrentTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CurrentTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto const result = interface::principia__CurrentTime(plugin);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void DeletePlugin::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(*in.plugin));
}

void DeletePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_plugin(SerializePointer(*out.plugin));
}

void DeletePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeletePlugin(&plugin);
  Delete(pointer_map, in.plugin());
}

void DeleteString::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_string(SerializePointer(*in.native_string));
}

void DeleteString::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_string(SerializePointer(*out.native_string));
}

void DeleteString::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto native_string = DeserializePointer<char const*>(pointer_map, in.native_string());
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeleteString(&native_string);
  Delete(pointer_map, in.native_string());
}

void DeleteU16String::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_string(SerializePointer(*in.native_string));
}

void DeleteU16String::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_string(SerializePointer(*out.native_string));
}

void DeleteU16String::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto native_string = DeserializePointer<char16_t const*>(pointer_map, in.native_string());
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeleteU16String(&native_string);
  Delete(pointer_map, in.native_string());
}

void DeserializePlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_serialization(std::string(in.serialization, in.serialization_size));
  m->set_deserializer(SerializePointer(*in.deserializer));
  m->set_plugin(SerializePointer(*in.plugin));
  m->set_compressor(in.compressor);
  m->set_encoder(in.encoder);
}

void DeserializePlugin::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_deserializer(SerializePointer(*out.deserializer));
  m->set_plugin(SerializePointer(*out.plugin));
}

void DeserializePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto serialization = &in.serialization();
  auto deserializer = DeserializePointer<PushDeserializer*>(pointer_map, in.deserializer());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto compressor = in.compressor().c_str();
  auto encoder = in.encoder().c_str();
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeserializePlugin(serialization->c_str(), serialization->size(), &deserializer, &plugin, compressor, encoder);
  if (serialization->empty()) {
    Delete(pointer_map, in.deserializer());
  }
  if (!serialization->empty()) {
    Insert(pointer_map, out.deserializer(), deserializer);
  }
  Insert(pointer_map, out.plugin(), plugin);
}

void EndInitialization::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void EndInitialization::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__EndInitialization(plugin);
}

void ExternalFlowFreefall::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_central_body_index(in.central_body_index);
  *m->mutable_world_body_centred_initial_degrees_of_freedom() = SerializeQP(in.world_body_centred_initial_degrees_of_freedom);
  m->set_t_initial(in.t_initial);
  m->set_t_final(in.t_final);
}

void ExternalFlowFreefall::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_world_body_centred_final_degrees_of_freedom() = SerializeQP(*out.world_body_centred_final_degrees_of_freedom);
}

void ExternalFlowFreefall::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void ExternalFlowFreefall::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto central_body_index = in.central_body_index();
  auto world_body_centred_initial_degrees_of_freedom = DeserializeQP(in.world_body_centred_initial_degrees_of_freedom());
  auto t_initial = in.t_initial();
  auto t_final = in.t_final();
  [[maybe_unused]] auto const& out = message.out();
  QP world_body_centred_final_degrees_of_freedom;
  auto const result = interface::principia__ExternalFlowFreefall(plugin, central_body_index, world_body_centred_initial_degrees_of_freedom, t_initial, t_final, &world_body_centred_final_degrees_of_freedom);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void ExternalGeopotentialGetCoefficient::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_body_index(in.body_index);
  m->set_degree(in.degree);
  m->set_order(in.order);
}

void ExternalGeopotentialGetCoefficient::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_coefficient() = SerializeXY(*out.coefficient);
}

void ExternalGeopotentialGetCoefficient::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void ExternalGeopotentialGetCoefficient::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto body_index = in.body_index();
  auto degree = in.degree();
  auto order = in.order();
  [[maybe_unused]] auto const& out = message.out();
  XY coefficient;
  auto const result = interface::principia__ExternalGeopotentialGetCoefficient(plugin, body_index, degree, order, &coefficient);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void ExternalGeopotentialGetReferenceRadius::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_body_index(in.body_index);
}

void ExternalGeopotentialGetReferenceRadius::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_reference_radius(*out.reference_radius);
}

void ExternalGeopotentialGetReferenceRadius::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void ExternalGeopotentialGetReferenceRadius::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto body_index = in.body_index();
  [[maybe_unused]] auto const& out = message.out();
  double reference_radius;
  auto const result = interface::principia__ExternalGeopotentialGetReferenceRadius(plugin, body_index, &reference_radius);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_central_body_index(in.central_body_index);
  m->set_vessel_guid(in.vessel_guid);
  m->set_manoeuvre_index(in.manoeuvre_index);
  *m->mutable_world_body_centred_reference_position() = SerializeXYZ(in.world_body_centred_reference_position);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_world_body_centred_nearest_degrees_of_freedom() = SerializeQP(*out.world_body_centred_nearest_degrees_of_freedom);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto central_body_index = in.central_body_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto manoeuvre_index = in.manoeuvre_index();
  auto world_body_centred_reference_position = DeserializeXYZ(in.world_body_centred_reference_position());
  [[maybe_unused]] auto const& out = message.out();
  QP world_body_centred_nearest_degrees_of_freedom;
  auto const result = interface::principia__ExternalGetNearestPlannedCoastDegreesOfFreedom(plugin, central_body_index, vessel_guid, manoeuvre_index, world_body_centred_reference_position, &world_body_centred_nearest_degrees_of_freedom);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void FlightPlanAppend::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
}

void FlightPlanAppend::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void FlightPlanAppend::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn());
  auto const result = interface::principia__FlightPlanAppend(plugin, vessel_guid, burn);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void FlightPlanCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
}

void FlightPlanCreate::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto mass_in_tonnes = in.mass_in_tonnes();
  interface::principia__FlightPlanCreate(plugin, vessel_guid, final_time, mass_in_tonnes);
}

void FlightPlanDelete::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanDelete(plugin, vessel_guid);
}

void FlightPlanExists::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanExists::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanExists::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanExists(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeFlightPlanAdaptiveStepParameters(result);
}

void FlightPlanGetAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetAdaptiveStepParameters(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeFlightPlanAdaptiveStepParameters(message.return_().result()), result);
}

void FlightPlanGetActualFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetActualFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetActualFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetActualFinalTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetDesiredFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetDesiredFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetDesiredFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetDesiredFinalTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetGuidance::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetGuidance::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void FlightPlanGetGuidance::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetGuidance(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void FlightPlanGetInitialTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetInitialTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetInitialTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetInitialTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetManoeuvre::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvre::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvre(result);
}

void FlightPlanGetManoeuvre::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvre(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeNavigationManoeuvre(message.return_().result()), result);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvreFrenetTrihedron(result);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvreFrenetTrihedron(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeNavigationManoeuvreFrenetTrihedron(message.return_().result()), result);
}

void FlightPlanNumberOfAnomalousManoeuvres::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfAnomalousManoeuvres::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfAnomalousManoeuvres::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfAnomalousManoeuvres(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanNumberOfManoeuvres::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfManoeuvres::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfManoeuvres::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfManoeuvres(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanNumberOfSegments::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfSegments::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfSegments::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfSegments(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanRemoveLast::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanRemoveLast::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void FlightPlanRemoveLast::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanRemoveLast(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void FlightPlanRenderedApsides::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void FlightPlanRenderedApsides::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_apoapsides(SerializePointer(*out.apoapsides));
  m->set_periapsides(SerializePointer(*out.periapsides));
}

void FlightPlanRenderedApsides::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* apoapsides;
  Iterator* periapsides;
  interface::principia__FlightPlanRenderedApsides(plugin, vessel_guid, celestial_index, sun_world_position, max_points, &apoapsides, &periapsides);
  Insert(pointer_map, out.apoapsides(), apoapsides);
  Insert(pointer_map, out.periapsides(), periapsides);
}

void FlightPlanRenderedClosestApproaches::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void FlightPlanRenderedClosestApproaches::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_closest_approaches(SerializePointer(*out.closest_approaches));
}

void FlightPlanRenderedClosestApproaches::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* closest_approaches;
  interface::principia__FlightPlanRenderedClosestApproaches(plugin, vessel_guid, sun_world_position, max_points, &closest_approaches);
  Insert(pointer_map, out.closest_approaches(), closest_approaches);
}

void FlightPlanRenderedNodes::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void FlightPlanRenderedNodes::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_ascending(SerializePointer(*out.ascending));
  m->set_descending(SerializePointer(*out.descending));
}

void FlightPlanRenderedNodes::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* ascending;
  Iterator* descending;
  interface::principia__FlightPlanRenderedNodes(plugin, vessel_guid, sun_world_position, max_points, &ascending, &descending);
  Insert(pointer_map, out.ascending(), ascending);
  Insert(pointer_map, out.descending(), descending);
}

void FlightPlanRenderedSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_index(in.index);
}

void FlightPlanRenderedSegment::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FlightPlanRenderedSegment::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto index = in.index();
  auto const result = interface::principia__FlightPlanRenderedSegment(plugin, vessel_guid, sun_world_position, index);
  Insert(pointer_map, message.return_().result(), result);
}

void FlightPlanReplace::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
  m->set_index(in.index);
}

void FlightPlanReplace::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void FlightPlanReplace::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn());
  auto index = in.index();
  auto const result = interface::principia__FlightPlanReplace(plugin, vessel_guid, burn, index);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void FlightPlanSetAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_flight_plan_adaptive_step_parameters() = SerializeFlightPlanAdaptiveStepParameters(in.flight_plan_adaptive_step_parameters);
}

void FlightPlanSetAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void FlightPlanSetAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto flight_plan_adaptive_step_parameters = DeserializeFlightPlanAdaptiveStepParameters(in.flight_plan_adaptive_step_parameters());
  auto const result = interface::principia__FlightPlanSetAdaptiveStepParameters(plugin, vessel_guid, flight_plan_adaptive_step_parameters);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void FlightPlanSetDesiredFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
}

void FlightPlanSetDesiredFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(result);
}

void FlightPlanSetDesiredFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto const result = interface::principia__FlightPlanSetDesiredFinalTime(plugin, vessel_guid, final_time);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result()), result);
}

void ForgetAllHistoriesBefore::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
}

void ForgetAllHistoriesBefore::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto t = in.t();
  interface::principia__ForgetAllHistoriesBefore(plugin, t);
}

void FreeVesselsAndPartsAndCollectPileUps::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_delta_t(in.delta_t);
}

void FreeVesselsAndPartsAndCollectPileUps::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto delta_t = in.delta_t();
  interface::principia__FreeVesselsAndPartsAndCollectPileUps(plugin, delta_t);
}

void FutureCatchUpVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FutureCatchUpVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FutureCatchUpVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FutureCatchUpVessel(plugin, vessel_guid);
  Insert(pointer_map, message.return_().result(), result);
}

void FutureWaitForVesselToCatchUp::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_future(SerializePointer(*in.future));
}

void FutureWaitForVesselToCatchUp::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_future(SerializePointer(*out.future));
  m->set_collided_vessels(SerializePointer(*out.collided_vessels));
}

void FutureWaitForVesselToCatchUp::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto future = DeserializePointer<PileUpFuture*>(pointer_map, in.future());
  [[maybe_unused]] auto const& out = message.out();
  Iterator* collided_vessels;
  interface::principia__FutureWaitForVesselToCatchUp(plugin, &future, &collided_vessels);
  Delete(pointer_map, in.future());
  Insert(pointer_map, out.collided_vessels(), collided_vessels);
}

void GetBufferDuration::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferDuration::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetBufferDuration();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetBufferedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetBufferedLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetStderrLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetStderrLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetStderrLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetSuppressedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetSuppressedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetSuppressedLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetVerboseLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetVerboseLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetVerboseLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetVersion::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_build_date(*out.build_date);
  m->set_version(*out.version);
}

void GetVersion::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& out = message.out();
  char const* build_date;
  char const* version;
  interface::principia__GetVersion(&build_date, &version);
}

void HasEncounteredApocalypse::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void HasEncounteredApocalypse::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_details(SerializePointer(*out.details));
}

void HasEncounteredApocalypse::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasEncounteredApocalypse::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  [[maybe_unused]] auto const& out = message.out();
  char const* details;
  auto const result = interface::principia__HasEncounteredApocalypse(plugin, &details);
  Insert(pointer_map, out.details(), details);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void HasVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void HasVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__HasVessel(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void InitializeEphemerisParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_accuracy_parameters() = SerializeConfigurationAccuracyParameters(in.accuracy_parameters);
  *m->mutable_fixed_step_parameters() = SerializeConfigurationFixedStepParameters(in.fixed_step_parameters);
}

void InitializeEphemerisParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto accuracy_parameters = DeserializeConfigurationAccuracyParameters(in.accuracy_parameters());
  auto fixed_step_parameters = DeserializeConfigurationFixedStepParameters(in.fixed_step_parameters());
  interface::principia__InitializeEphemerisParameters(plugin, accuracy_parameters, fixed_step_parameters);
}

void InitializeHistoryParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeConfigurationFixedStepParameters(in.parameters);
}

void InitializeHistoryParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto parameters = DeserializeConfigurationFixedStepParameters(in.parameters());
  interface::principia__InitializeHistoryParameters(plugin, parameters);
}

void InitializePsychohistoryParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeConfigurationAdaptiveStepParameters(in.parameters);
}

void InitializePsychohistoryParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto parameters = DeserializeConfigurationAdaptiveStepParameters(in.parameters());
  interface::principia__InitializePsychohistoryParameters(plugin, parameters);
}

void InsertCelestialAbsoluteCartesian::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  *m->mutable_body_parameters() = SerializeBodyParameters(in.body_parameters);
  m->set_x(in.x);
  m->set_y(in.y);
  m->set_z(in.z);
  m->set_vx(in.vx);
  m->set_vy(in.vy);
  m->set_vz(in.vz);
}

void InsertCelestialAbsoluteCartesian::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.has_parent_index() ? std::make_unique<int const>(in.parent_index()) : nullptr;
  std::vector<BodyGeopotentialElement> geopotential_storage;
  auto body_parameters = DeserializeBodyParameters(in.body_parameters(), geopotential_storage);
  auto x = in.x().c_str();
  auto y = in.y().c_str();
  auto z = in.z().c_str();
  auto vx = in.vx().c_str();
  auto vy = in.vy().c_str();
  auto vz = in.vz().c_str();
  interface::principia__InsertCelestialAbsoluteCartesian(plugin, celestial_index, parent_index.get(), body_parameters, x, y, z, vx, vy, vz);
}

void InsertCelestialJacobiKeplerian::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  *m->mutable_body_parameters() = SerializeBodyParameters(in.body_parameters);
  if (in.keplerian_elements != nullptr) {
    *m->mutable_keplerian_elements() = SerializeKeplerianElements(*in.keplerian_elements);
  }
}

void InsertCelestialJacobiKeplerian::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.has_parent_index() ? std::make_unique<int const>(in.parent_index()) : nullptr;
  std::vector<BodyGeopotentialElement> geopotential_storage;
  auto body_parameters = DeserializeBodyParameters(in.body_parameters(), geopotential_storage);
  auto keplerian_elements = in.has_keplerian_elements() ? std::make_unique<KeplerianElements const>(DeserializeKeplerianElements(in.keplerian_elements())) : nullptr;
  interface::principia__InsertCelestialJacobiKeplerian(plugin, celestial_index, parent_index.get(), body_parameters, keplerian_elements.get());
}

void InsertOrKeepVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_vessel_name(in.vessel_name);
  m->set_parent_index(in.parent_index);
  m->set_loaded(in.loaded);
}

void InsertOrKeepVessel::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_inserted(*out.inserted);
}

void InsertOrKeepVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto vessel_name = in.vessel_name().c_str();
  auto parent_index = in.parent_index();
  auto loaded = in.loaded();
  [[maybe_unused]] auto const& out = message.out();
  bool inserted;
  interface::principia__InsertOrKeepVessel(plugin, vessel_guid, vessel_name, parent_index, loaded, &inserted);
}

void InsertOrKeepLoadedPart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  m->set_name(in.name);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
  *m->mutable_moments_of_inertia_in_tonnes() = SerializeXYZ(in.moments_of_inertia_in_tonnes);
  *m->mutable_principal_axes_rotation() = SerializeWXYZ(in.principal_axes_rotation);
  m->set_is_solid_rocket_motor(in.is_solid_rocket_motor);
  m->set_vessel_guid(in.vessel_guid);
  m->set_main_body_index(in.main_body_index);
  *m->mutable_main_body_world_degrees_of_freedom() = SerializeQP(in.main_body_world_degrees_of_freedom);
  *m->mutable_part_world_degrees_of_freedom() = SerializeQP(in.part_world_degrees_of_freedom);
  *m->mutable_part_rotation() = SerializeWXYZ(in.part_rotation);
  *m->mutable_part_angular_velocity() = SerializeXYZ(in.part_angular_velocity);
  m->set_delta_t(in.delta_t);
}

void InsertOrKeepLoadedPart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto name = in.name().c_str();
  auto mass_in_tonnes = in.mass_in_tonnes();
  auto moments_of_inertia_in_tonnes = DeserializeXYZ(in.moments_of_inertia_in_tonnes());
  auto principal_axes_rotation = DeserializeWXYZ(in.principal_axes_rotation());
  auto is_solid_rocket_motor = in.is_solid_rocket_motor();
  auto vessel_guid = in.vessel_guid().c_str();
  auto main_body_index = in.main_body_index();
  auto main_body_world_degrees_of_freedom = DeserializeQP(in.main_body_world_degrees_of_freedom());
  auto part_world_degrees_of_freedom = DeserializeQP(in.part_world_degrees_of_freedom());
  auto part_rotation = DeserializeWXYZ(in.part_rotation());
  auto part_angular_velocity = DeserializeXYZ(in.part_angular_velocity());
  auto delta_t = in.delta_t();
  interface::principia__InsertOrKeepLoadedPart(plugin, part_id, name, mass_in_tonnes, moments_of_inertia_in_tonnes, principal_axes_rotation, is_solid_rocket_motor, vessel_guid, main_body_index, main_body_world_degrees_of_freedom, part_world_degrees_of_freedom, part_rotation, part_angular_velocity, delta_t);
}

void InsertUnloadedPart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  m->set_name(in.name);
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_from_parent() = SerializeQP(in.from_parent);
}

void InsertUnloadedPart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto name = in.name().c_str();
  auto vessel_guid = in.vessel_guid().c_str();
  auto from_parent = DeserializeQP(in.from_parent());
  interface::principia__InsertUnloadedPart(plugin, part_id, name, vessel_guid, from_parent);
}

void IteratorAtEnd::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorAtEnd::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorAtEnd::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorAtEnd(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IteratorDelete::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(*in.iterator));
}

void IteratorDelete::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_iterator(SerializePointer(*out.iterator));
}

void IteratorDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(pointer_map, in.iterator());
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__IteratorDelete(&iterator);
  Delete(pointer_map, in.iterator());
}

void IteratorGetDiscreteTrajectoryQP::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryQP::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void IteratorGetDiscreteTrajectoryQP::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryQP(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void IteratorGetDiscreteTrajectoryTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorGetDiscreteTrajectoryTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryTime(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IteratorGetDiscreteTrajectoryXYZ::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryXYZ::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void IteratorGetDiscreteTrajectoryXYZ::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryXYZ(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void IteratorGetRP2LinesIterator::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetRP2LinesIterator::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void IteratorGetRP2LinesIterator::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetRP2LinesIterator(iterator);
  Insert(pointer_map, message.return_().result(), result);
}

void IteratorGetRP2LineXY::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetRP2LineXY::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXY(result);
}

void IteratorGetRP2LineXY::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetRP2LineXY(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeXY(message.return_().result()), result);
}

void IteratorGetVesselGuid::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetVesselGuid::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorGetVesselGuid::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorGetVesselGuid(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result().c_str(), result);
}

void IteratorIncrement::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorIncrement::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(pointer_map, in.iterator());
  interface::principia__IteratorIncrement(iterator);
}

void IteratorReset::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorReset::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(pointer_map, in.iterator());
  interface::principia__IteratorReset(iterator);
}

void IteratorSize::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorSize::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorSize::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(pointer_map, in.iterator());
  auto const result = interface::principia__IteratorSize(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void LogError::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogError::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogError(file, line, text);
}

void LogFatal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogFatal::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogFatal(file, line, text);
}

void LogInfo::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogInfo::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogInfo(file, line, text);
}

void LogWarning::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogWarning::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogWarning(file, line, text);
}

void MonitorSetName::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_i(in.i);
  m->set_name(in.name);
}

void MonitorSetName::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto i = in.i();
  auto name = in.name().c_str();
  interface::principia__MonitorSetName(i, name);
}

void MonitorStart::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_i(in.i);
}

void MonitorStart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto i = in.i();
  interface::principia__MonitorStart(i);
}

void MonitorStop::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_i(in.i);
}

void MonitorStop::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto i = in.i();
  interface::principia__MonitorStop(i);
}

void NavballOrientation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_ship_world_position() = SerializeXYZ(in.ship_world_position);
}

void NavballOrientation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void NavballOrientation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto ship_world_position = DeserializeXYZ(in.ship_world_position());
  auto const result = interface::principia__NavballOrientation(plugin, sun_world_position, ship_world_position);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result()), result);
}

void NewPlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_game_epoch(in.game_epoch);
  m->set_solar_system_epoch(in.solar_system_epoch);
  m->set_planetarium_rotation_in_degrees(in.planetarium_rotation_in_degrees);
}

void NewPlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewPlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto game_epoch = in.game_epoch().c_str();
  auto solar_system_epoch = in.solar_system_epoch().c_str();
  auto planetarium_rotation_in_degrees = in.planetarium_rotation_in_degrees();
  auto const result = interface::principia__NewPlugin(game_epoch, solar_system_epoch, planetarium_rotation_in_degrees);
  Insert(pointer_map, message.return_().result(), result);
}

void PartApplyIntrinsicForce::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_force_in_kilonewtons() = SerializeXYZ(in.force_in_kilonewtons);
}

void PartApplyIntrinsicForce::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto force_in_kilonewtons = DeserializeXYZ(in.force_in_kilonewtons());
  interface::principia__PartApplyIntrinsicForce(plugin, part_id, force_in_kilonewtons);
}

void PartApplyIntrinsicForceAtPosition::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_force_in_kilonewtons() = SerializeXYZ(in.force_in_kilonewtons);
  *m->mutable_point_of_force_application() = SerializeXYZ(in.point_of_force_application);
  *m->mutable_part_position() = SerializeXYZ(in.part_position);
}

void PartApplyIntrinsicForceAtPosition::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto force_in_kilonewtons = DeserializeXYZ(in.force_in_kilonewtons());
  auto point_of_force_application = DeserializeXYZ(in.point_of_force_application());
  auto part_position = DeserializeXYZ(in.part_position());
  interface::principia__PartApplyIntrinsicForceAtPosition(plugin, part_id, force_in_kilonewtons, point_of_force_application, part_position);
}

void PartApplyIntrinsicTorque::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_torque_in_kilonewton_metre() = SerializeXYZ(in.torque_in_kilonewton_metre);
}

void PartApplyIntrinsicTorque::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto torque_in_kilonewton_metre = DeserializeXYZ(in.torque_in_kilonewton_metre());
  interface::principia__PartApplyIntrinsicTorque(plugin, part_id, torque_in_kilonewton_metre);
}

void PartGetActualDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_origin() = SerializeOrigin(in.origin);
}

void PartGetActualDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQPRW(result);
}

void PartGetActualDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto origin = DeserializeOrigin(in.origin());
  auto const result = interface::principia__PartGetActualDegreesOfFreedom(plugin, part_id, origin);
  PRINCIPIA_CHECK_EQ(DeserializeQPRW(message.return_().result()), result);
}

void PartIsTruthful::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
}

void PartIsTruthful::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void PartIsTruthful::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto const result = interface::principia__PartIsTruthful(plugin, part_id);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void PartSetApparentRigidMotion::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_degrees_of_freedom() = SerializeQP(in.degrees_of_freedom);
  *m->mutable_rotation() = SerializeWXYZ(in.rotation);
  *m->mutable_angular_velocity() = SerializeXYZ(in.angular_velocity);
  *m->mutable_main_body_degrees_of_freedom() = SerializeQP(in.main_body_degrees_of_freedom);
}

void PartSetApparentRigidMotion::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  auto degrees_of_freedom = DeserializeQP(in.degrees_of_freedom());
  auto rotation = DeserializeWXYZ(in.rotation());
  auto angular_velocity = DeserializeXYZ(in.angular_velocity());
  auto main_body_degrees_of_freedom = DeserializeQP(in.main_body_degrees_of_freedom());
  interface::principia__PartSetApparentRigidMotion(plugin, part_id, degrees_of_freedom, rotation, angular_velocity, main_body_degrees_of_freedom);
}

void PlanetariumCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_xyz_opengl_camera_x_in_world() = SerializeXYZ(in.xyz_opengl_camera_x_in_world);
  *m->mutable_xyz_opengl_camera_y_in_world() = SerializeXYZ(in.xyz_opengl_camera_y_in_world);
  *m->mutable_xyz_opengl_camera_z_in_world() = SerializeXYZ(in.xyz_opengl_camera_z_in_world);
  *m->mutable_xyz_camera_position_in_world() = SerializeXYZ(in.xyz_camera_position_in_world);
  m->set_focal(in.focal);
  m->set_field_of_view(in.field_of_view);
}

void PlanetariumCreate::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void PlanetariumCreate::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto xyz_opengl_camera_x_in_world = DeserializeXYZ(in.xyz_opengl_camera_x_in_world());
  auto xyz_opengl_camera_y_in_world = DeserializeXYZ(in.xyz_opengl_camera_y_in_world());
  auto xyz_opengl_camera_z_in_world = DeserializeXYZ(in.xyz_opengl_camera_z_in_world());
  auto xyz_camera_position_in_world = DeserializeXYZ(in.xyz_camera_position_in_world());
  auto focal = in.focal();
  auto field_of_view = in.field_of_view();
  auto const result = interface::principia__PlanetariumCreate(plugin, sun_world_position, xyz_opengl_camera_x_in_world, xyz_opengl_camera_y_in_world, xyz_opengl_camera_z_in_world, xyz_camera_position_in_world, focal, field_of_view);
  Insert(pointer_map, message.return_().result(), result);
}

void PlanetariumDelete::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_planetarium(SerializePointer(*in.planetarium));
}

void PlanetariumDelete::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_planetarium(SerializePointer(*out.planetarium));
}

void PlanetariumDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__PlanetariumDelete(&planetarium);
  Delete(pointer_map, in.planetarium());
}

void PlanetariumPlotCelestialTrajectoryForPsychohistory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.vessel_guid != nullptr) {
    m->set_vessel_guid(in.vessel_guid);
  }
  m->set_max_history_length(in.max_history_length);
}

void PlanetariumPlotCelestialTrajectoryForPsychohistory::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotCelestialTrajectoryForPsychohistory::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto vessel_guid = in.has_vessel_guid() ? in.vessel_guid().c_str() : nullptr;
  auto max_history_length = in.max_history_length();
  auto const result = interface::principia__PlanetariumPlotCelestialTrajectoryForPsychohistory(planetarium, plugin, celestial_index, vessel_guid, max_history_length);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PlanetariumPlotCelestialTrajectoryForPredictionOrFlightPlan::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_vessel_guid(in.vessel_guid);
}

void PlanetariumPlotCelestialTrajectoryForPredictionOrFlightPlan::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotCelestialTrajectoryForPredictionOrFlightPlan::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__PlanetariumPlotCelestialTrajectoryForPredictionOrFlightPlan(planetarium, plugin, celestial_index, vessel_guid);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PlanetariumPlotFlightPlanSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_method(in.method);
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void PlanetariumPlotFlightPlanSegment::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotFlightPlanSegment::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto method = in.method();
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__PlanetariumPlotFlightPlanSegment(planetarium, plugin, method, vessel_guid, index);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PlanetariumPlotPrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_method(in.method);
  m->set_vessel_guid(in.vessel_guid);
}

void PlanetariumPlotPrediction::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotPrediction::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto method = in.method();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__PlanetariumPlotPrediction(planetarium, plugin, method, vessel_guid);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PlanetariumPlotPsychohistory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_method(in.method);
  m->set_vessel_guid(in.vessel_guid);
  m->set_max_history_length(in.max_history_length);
}

void PlanetariumPlotPsychohistory::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_rp2_lines(SerializePointer(result));
}

void PlanetariumPlotPsychohistory::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(pointer_map, in.planetarium());
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto method = in.method();
  auto vessel_guid = in.vessel_guid().c_str();
  auto max_history_length = in.max_history_length();
  auto const result = interface::principia__PlanetariumPlotPsychohistory(planetarium, plugin, method, vessel_guid, max_history_length);
  Insert(pointer_map, message.return_().rp2_lines(), result);
}

void PrepareToReportCollisions::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void PrepareToReportCollisions::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  interface::principia__PrepareToReportCollisions(plugin);
}

void RenderedPredictionApsides::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void RenderedPredictionApsides::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_apoapsides(SerializePointer(*out.apoapsides));
  m->set_periapsides(SerializePointer(*out.periapsides));
}

void RenderedPredictionApsides::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* apoapsides;
  Iterator* periapsides;
  interface::principia__RenderedPredictionApsides(plugin, vessel_guid, celestial_index, sun_world_position, max_points, &apoapsides, &periapsides);
  Insert(pointer_map, out.apoapsides(), apoapsides);
  Insert(pointer_map, out.periapsides(), periapsides);
}

void RenderedPredictionClosestApproaches::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void RenderedPredictionClosestApproaches::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_closest_approaches(SerializePointer(*out.closest_approaches));
}

void RenderedPredictionClosestApproaches::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* closest_approaches;
  interface::principia__RenderedPredictionClosestApproaches(plugin, vessel_guid, sun_world_position, max_points, &closest_approaches);
  Insert(pointer_map, out.closest_approaches(), closest_approaches);
}

void RenderedPredictionNodes::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void RenderedPredictionNodes::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_ascending(SerializePointer(*out.ascending));
  m->set_descending(SerializePointer(*out.descending));
}

void RenderedPredictionNodes::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* ascending;
  Iterator* descending;
  interface::principia__RenderedPredictionNodes(plugin, vessel_guid, sun_world_position, max_points, &ascending, &descending);
  Insert(pointer_map, out.ascending(), ascending);
  Insert(pointer_map, out.descending(), descending);
}

void ReportGroundCollision::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
}

void ReportGroundCollision::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part_id = in.part_id();
  interface::principia__ReportGroundCollision(plugin, part_id);
}

void ReportPartCollision::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part1_id(in.part1_id);
  m->set_part2_id(in.part2_id);
}

void ReportPartCollision::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto part1_id = in.part1_id();
  auto part2_id = in.part2_id();
  interface::principia__ReportPartCollision(plugin, part1_id, part2_id);
}

void SayHello::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void SayHello::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__SayHello();
  PRINCIPIA_CHECK_EQ(message.return_().result().c_str(), result);
}

void SerializePlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_serializer(SerializePointer(*in.serializer));
  m->set_compressor(in.compressor);
  m->set_encoder(in.encoder);
}

void SerializePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_serializer(SerializePointer(*out.serializer));
}

void SerializePlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void SerializePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto serializer = DeserializePointer<PullSerializer*>(pointer_map, in.serializer());
  auto compressor = in.compressor().c_str();
  auto encoder = in.encoder().c_str();
  [[maybe_unused]] auto const& out = message.out();
  auto const result = interface::principia__SerializePlugin(plugin, &serializer, compressor, encoder);
  if (result == nullptr) {
    Delete(pointer_map, in.serializer());
  }
  if (result != nullptr) {
    Insert(pointer_map, out.serializer(), serializer);
  }
  if (result != nullptr) {
    Insert(pointer_map, message.return_().result(), result);
  }
}

void SetBufferDuration::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_seconds(in.seconds);
}

void SetBufferDuration::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto seconds = in.seconds();
  interface::principia__SetBufferDuration(seconds);
}

void SetBufferedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_max_severity(in.max_severity);
}

void SetBufferedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto max_severity = in.max_severity();
  interface::principia__SetBufferedLogging(max_severity);
}

void SetFlag::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_name(in.name);
  m->set_value(in.value);
}

void SetFlag::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto name = in.name().c_str();
  auto value = in.value().c_str();
  interface::principia__SetFlag(name, value);
}

void SetMainBody::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void SetMainBody::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto index = in.index();
  interface::principia__SetMainBody(plugin, index);
}

void SetPlottingFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeNavigationFrameParameters(in.parameters);
}

void SetPlottingFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto parameters = DeserializeNavigationFrameParameters(in.parameters());
  interface::principia__SetPlottingFrame(plugin, parameters);
}

void SetStderrLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetStderrLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetStderrLogging(min_severity);
}

void SetSuppressedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetSuppressedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetSuppressedLogging(min_severity);
}

void SetTargetVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_reference_body_index(in.reference_body_index);
}

void SetTargetVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto reference_body_index = in.reference_body_index();
  interface::principia__SetTargetVessel(plugin, vessel_guid, reference_body_index);
}

void SetVerboseLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_level(in.level);
}

void SetVerboseLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto level = in.level();
#if PRINCIPIA_SET_VERBOSE_LOGGING
  interface::principia__SetVerboseLogging(level);
#endif
}

void SetWorldRotationalReferenceFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void SetWorldRotationalReferenceFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(pointer_map, in.plugin());
  auto index = in.index();
  interface::principia__SetWorldRotationalReferenceFrame(plugin, index);
}

void UnmanageableVesselVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_degrees_of_freedom() = SerializeQP(in.degrees_of_freedom);
  m->set_celestial_index(in.celestial_index);
}

void UnmanageableVesselVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void UnmanageableVesselVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto degrees_of_freedom = DeserializeQP(in.degrees_of_freedom());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__UnmanageableVesselVelocity(plugin, degrees_of_freedom, celestial_index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void UpdateCelestialHierarchy::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_parent_index(in.parent_index);
}

void UpdateCelestialHierarchy::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.parent_index();
  interface::principia__UpdateCelestialHierarchy(plugin, celestial_index, parent_index);
}

void UpdatePrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void UpdatePrediction::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__UpdatePrediction(plugin, vessel_guid);
}

void VesselBinormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselBinormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselBinormal::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselBinormal(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void VesselFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_parent_index(in.parent_index);
  m->set_vessel_guid(in.vessel_guid);
}

void VesselFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void VesselFromParent::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto parent_index = in.parent_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselFromParent(plugin, parent_index, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result()), result);
}

void VesselGetPredictionAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselGetPredictionAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(result);
}

void VesselGetPredictionAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselGetPredictionAdaptiveStepParameters(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeAdaptiveStepParameters(message.return_().adaptive_step_parameters()), result);
}

void VesselNormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselNormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselNormal::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselNormal(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void VesselRefreshAnalysis::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_primary_index(in.primary_index);
  m->set_mission_duration(in.mission_duration);
  if (in.revolutions_per_cycle != nullptr) {
    m->set_revolutions_per_cycle(*in.revolutions_per_cycle);
  }
  if (in.days_per_cycle != nullptr) {
    m->set_days_per_cycle(*in.days_per_cycle);
  }
  m->set_ground_track_revolution(in.ground_track_revolution);
}

void VesselRefreshAnalysis::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeOrbitAnalysis(result);
}

void VesselRefreshAnalysis::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto primary_index = in.primary_index();
  auto mission_duration = in.mission_duration();
  auto revolutions_per_cycle = in.has_revolutions_per_cycle() ? std::make_unique<int const>(in.revolutions_per_cycle()) : nullptr;
  auto days_per_cycle = in.has_days_per_cycle() ? std::make_unique<int const>(in.days_per_cycle()) : nullptr;
  auto ground_track_revolution = in.ground_track_revolution();
  auto const result = interface::principia__VesselRefreshAnalysis(plugin, vessel_guid, primary_index, mission_duration, revolutions_per_cycle.get(), days_per_cycle.get(), ground_track_revolution);
  PRINCIPIA_CHECK_EQ(DeserializeOrbitAnalysis(message.return_().result()), result);
}

void VesselSetPredictionAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(in.adaptive_step_parameters);
}

void VesselSetPredictionAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto adaptive_step_parameters = DeserializeAdaptiveStepParameters(in.adaptive_step_parameters());
  interface::principia__VesselSetPredictionAdaptiveStepParameters(plugin, vessel_guid, adaptive_step_parameters);
}

void VesselTangent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselTangent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselTangent::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselTangent(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

void VesselVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselVelocity(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result()), result);
}

