// Warning!  This file was generated by running a program (see project |tools|).
// If you change it, the changes will be lost the next time the generator is
// run.  You should change the generator instead.

namespace {

NavigationFrameParameters DeserializeNavigationFrameParameters(serialization::NavigationFrameParameters const& navigation_frame_parameters, Player::PointerMap& pointer_map) {
  return {navigation_frame_parameters.extension(),
          navigation_frame_parameters.centre_index(),
          navigation_frame_parameters.primary_index(),
          navigation_frame_parameters.secondary_index()};
}

XYZ DeserializeXYZ(serialization::XYZ const& xyz, Player::PointerMap& pointer_map) {
  return {xyz.x(),
          xyz.y(),
          xyz.z()};
}

AdaptiveStepParameters DeserializeAdaptiveStepParameters(serialization::AdaptiveStepParameters const& adaptive_step_parameters, Player::PointerMap& pointer_map) {
  return {adaptive_step_parameters.integrator_kind(),
          adaptive_step_parameters.max_steps(),
          adaptive_step_parameters.length_integration_tolerance(),
          adaptive_step_parameters.speed_integration_tolerance()};
}

BodyGeopotentialElement DeserializeBodyGeopotentialElement(serialization::BodyGeopotentialElement const& body_geopotential_element, Player::PointerMap& pointer_map) {
  return {body_geopotential_element.degree().c_str(),
          body_geopotential_element.order().c_str(),
          body_geopotential_element.has_cos() ? body_geopotential_element.cos().c_str() : nullptr,
          body_geopotential_element.has_j() ? body_geopotential_element.j().c_str() : nullptr,
          body_geopotential_element.sin().c_str()};
}

BodyParameters DeserializeBodyParameters(serialization::BodyParameters const& body_parameters, Player::PointerMap& pointer_map, std::pair<std::vector<BodyGeopotentialElement>, std::vector<BodyGeopotentialElement const*>>& geopotential_storage) {
  return {body_parameters.name().c_str(),
          body_parameters.gravitational_parameter().c_str(),
          body_parameters.has_reference_instant() ? body_parameters.reference_instant().c_str() : nullptr,
          body_parameters.has_min_radius() ? body_parameters.min_radius().c_str() : nullptr,
          body_parameters.has_mean_radius() ? body_parameters.mean_radius().c_str() : nullptr,
          body_parameters.has_max_radius() ? body_parameters.max_radius().c_str() : nullptr,
          body_parameters.has_axis_right_ascension() ? body_parameters.axis_right_ascension().c_str() : nullptr,
          body_parameters.has_axis_declination() ? body_parameters.axis_declination().c_str() : nullptr,
          body_parameters.has_reference_angle() ? body_parameters.reference_angle().c_str() : nullptr,
          body_parameters.has_angular_frequency() ? body_parameters.angular_frequency().c_str() : nullptr,
          body_parameters.has_reference_radius() ? body_parameters.reference_radius().c_str() : nullptr,
          body_parameters.has_j2() ? body_parameters.j2().c_str() : nullptr,
          [&pointer_map, &geopotential_storage](::google::protobuf::RepeatedPtrField<serialization::BodyGeopotentialElement> const& messages) {
            for (auto const& message : messages) {
              geopotential_storage.first.push_back(DeserializeBodyGeopotentialElement(message, pointer_map));
              geopotential_storage.second.push_back(&geopotential_storage.first.back());
            }
            return &geopotential_storage.second[0];
          }(body_parameters.geopotential())};
}

Burn DeserializeBurn(serialization::Burn const& burn, Player::PointerMap& pointer_map) {
  return {burn.thrust_in_kilonewtons(),
          burn.specific_impulse_in_seconds_g0(),
          DeserializeNavigationFrameParameters(burn.frame(), pointer_map),
          burn.initial_time(),
          DeserializeXYZ(burn.delta_v(), pointer_map),
          burn.is_inertially_fixed()};
}

ConfigurationAccuracyParameters DeserializeConfigurationAccuracyParameters(serialization::ConfigurationAccuracyParameters const& configuration_accuracy_parameters, Player::PointerMap& pointer_map) {
  return {configuration_accuracy_parameters.fitting_tolerance().c_str(),
          configuration_accuracy_parameters.geopotential_tolerance().c_str()};
}

ConfigurationDownsamplingParameters DeserializeConfigurationDownsamplingParameters(serialization::ConfigurationDownsamplingParameters const& configuration_downsampling_parameters, Player::PointerMap& pointer_map) {
  return {configuration_downsampling_parameters.max_dense_intervals().c_str(),
          configuration_downsampling_parameters.tolerance().c_str()};
}

ConfigurationFixedStepParameters DeserializeConfigurationFixedStepParameters(serialization::ConfigurationFixedStepParameters const& configuration_fixed_step_parameters, Player::PointerMap& pointer_map) {
  return {configuration_fixed_step_parameters.fixed_step_size_integrator().c_str(),
          configuration_fixed_step_parameters.integration_step_size().c_str()};
}

ConfigurationAdaptiveStepParameters DeserializeConfigurationAdaptiveStepParameters(serialization::ConfigurationAdaptiveStepParameters const& configuration_adaptive_step_parameters, Player::PointerMap& pointer_map) {
  return {configuration_adaptive_step_parameters.adaptive_step_size_integrator().c_str(),
          configuration_adaptive_step_parameters.length_integration_tolerance().c_str(),
          configuration_adaptive_step_parameters.speed_integration_tolerance().c_str()};
}

FlightPlanAdaptiveStepParameters DeserializeFlightPlanAdaptiveStepParameters(serialization::FlightPlanAdaptiveStepParameters const& flight_plan_adaptive_step_parameters, Player::PointerMap& pointer_map) {
  return {flight_plan_adaptive_step_parameters.integrator_kind(),
          flight_plan_adaptive_step_parameters.generalized_integrator_kind(),
          flight_plan_adaptive_step_parameters.max_steps(),
          flight_plan_adaptive_step_parameters.length_integration_tolerance(),
          flight_plan_adaptive_step_parameters.speed_integration_tolerance()};
}

KeplerianElements DeserializeKeplerianElements(serialization::KeplerianElements const& keplerian_elements, Player::PointerMap& pointer_map) {
  return {keplerian_elements.eccentricity(),
          keplerian_elements.semimajor_axis(),
          keplerian_elements.mean_motion(),
          keplerian_elements.inclination_in_degrees(),
          keplerian_elements.longitude_of_ascending_node_in_degrees(),
          keplerian_elements.argument_of_periapsis_in_degrees(),
          keplerian_elements.mean_anomaly()};
}

NavigationManoeuvre DeserializeNavigationManoeuvre(serialization::NavigationManoeuvre const& navigation_manoeuvre, Player::PointerMap& pointer_map) {
  return {DeserializeBurn(navigation_manoeuvre.burn(), pointer_map),
          navigation_manoeuvre.initial_mass_in_tonnes(),
          navigation_manoeuvre.final_mass_in_tonnes(),
          navigation_manoeuvre.mass_flow(),
          navigation_manoeuvre.duration(),
          navigation_manoeuvre.final_time(),
          navigation_manoeuvre.time_of_half_delta_v(),
          navigation_manoeuvre.time_to_half_delta_v()};
}

NavigationManoeuvreFrenetTrihedron DeserializeNavigationManoeuvreFrenetTrihedron(serialization::NavigationManoeuvreFrenetTrihedron const& navigation_manoeuvre_frenet_trihedron, Player::PointerMap& pointer_map) {
  return {DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.binormal(), pointer_map),
          DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.normal(), pointer_map),
          DeserializeXYZ(navigation_manoeuvre_frenet_trihedron.tangent(), pointer_map)};
}

Node DeserializeNode(serialization::Node const& node, Player::PointerMap& pointer_map) {
  return {node.time(),
          DeserializeXYZ(node.world_position(), pointer_map),
          node.apparent_inclination_in_degrees(),
          node.out_of_plane_velocity()};
}

Origin DeserializeOrigin(serialization::Origin const& origin, Player::PointerMap& pointer_map) {
  return {origin.reference_part_is_at_origin(),
          origin.reference_part_is_unmoving(),
          origin.reference_part_id(),
          DeserializeXYZ(origin.main_body_centre_in_world(), pointer_map)};
}

PlottingFrameParameters DeserializePlottingFrameParameters(serialization::PlottingFrameParameters const& plotting_frame_parameters, Player::PointerMap& pointer_map, std::vector<int const*>& primary_index_storage, std::vector<int const*>& secondary_index_storage) {
  return {plotting_frame_parameters.extension(),
          plotting_frame_parameters.centre_index(),
          [&primary_index_storage](::google::protobuf::RepeatedField<int> const& values) {
            for (auto const& v : values) {
              primary_index_storage.push_back(&v);
            }
            primary_index_storage.push_back(nullptr);
            return &primary_index_storage[0];
          }(plotting_frame_parameters.primary_index()),
          [&secondary_index_storage](::google::protobuf::RepeatedField<int> const& values) {
            for (auto const& v : values) {
              secondary_index_storage.push_back(&v);
            }
            secondary_index_storage.push_back(nullptr);
            return &secondary_index_storage[0];
          }(plotting_frame_parameters.secondary_index())};
}

QP DeserializeQP(serialization::QP const& qp, Player::PointerMap& pointer_map) {
  return {DeserializeXYZ(qp.q(), pointer_map),
          DeserializeXYZ(qp.p(), pointer_map)};
}

TQP DeserializeTQP(serialization::TQP const& tqp, Player::PointerMap& pointer_map) {
  return {tqp.t(),
          DeserializeQP(tqp.qp(), pointer_map)};
}

Status DeserializeStatus(serialization::Status const& status, Player::PointerMap& pointer_map) {
  return {status.error(),
          DeserializePointer<char const*>(status.message(), pointer_map)};
}

WXYZ DeserializeWXYZ(serialization::WXYZ const& wxyz, Player::PointerMap& pointer_map) {
  return {wxyz.w(),
          wxyz.x(),
          wxyz.y(),
          wxyz.z()};
}

QPRW DeserializeQPRW(serialization::QPRW const& qprw, Player::PointerMap& pointer_map) {
  return {DeserializeQP(qprw.qp(), pointer_map),
          DeserializeWXYZ(qprw.r(), pointer_map),
          DeserializeXYZ(qprw.w(), pointer_map)};
}

XY DeserializeXY(serialization::XY const& xy, Player::PointerMap& pointer_map) {
  return {xy.x(),
          xy.y()};
}

Interval DeserializeInterval(serialization::Interval const& interval, Player::PointerMap& pointer_map) {
  return {interval.min(),
          interval.max()};
}

OrbitalElements DeserializeOrbitalElements(serialization::OrbitalElements const& orbital_elements, Player::PointerMap& pointer_map) {
  return {orbital_elements.sidereal_period(),
          orbital_elements.nodal_period(),
          orbital_elements.anomalistic_period(),
          orbital_elements.nodal_precession(),
          DeserializeInterval(orbital_elements.mean_semimajor_axis(), pointer_map),
          DeserializeInterval(orbital_elements.mean_eccentricity(), pointer_map),
          DeserializeInterval(orbital_elements.mean_inclination(), pointer_map),
          DeserializeInterval(orbital_elements.mean_longitude_of_ascending_nodes(), pointer_map),
          DeserializeInterval(orbital_elements.mean_argument_of_periapsis(), pointer_map),
          DeserializeInterval(orbital_elements.mean_periapsis_distance(), pointer_map),
          DeserializeInterval(orbital_elements.mean_apoapsis_distance(), pointer_map),
          DeserializeInterval(orbital_elements.radial_distance(), pointer_map)};
}

OrbitRecurrence DeserializeOrbitRecurrence(serialization::OrbitRecurrence const& orbit_recurrence, Player::PointerMap& pointer_map) {
  return {orbit_recurrence.nuo(),
          orbit_recurrence.dto(),
          orbit_recurrence.cto(),
          orbit_recurrence.number_of_revolutions(),
          orbit_recurrence.equatorial_shift(),
          orbit_recurrence.base_interval(),
          orbit_recurrence.grid_interval(),
          orbit_recurrence.subcycle()};
}

EquatorialCrossings DeserializeEquatorialCrossings(serialization::EquatorialCrossings const& equatorial_crossings, Player::PointerMap& pointer_map) {
  return {DeserializeInterval(equatorial_crossings.longitudes_reduced_to_ascending_pass(), pointer_map),
          DeserializeInterval(equatorial_crossings.longitudes_reduced_to_descending_pass(), pointer_map)};
}

SolarTimesOfNodes DeserializeSolarTimesOfNodes(serialization::SolarTimesOfNodes const& solar_times_of_nodes, Player::PointerMap& pointer_map) {
  return {DeserializeInterval(solar_times_of_nodes.mean_solar_times_of_ascending_nodes(), pointer_map),
          DeserializeInterval(solar_times_of_nodes.mean_solar_times_of_descending_nodes(), pointer_map)};
}

OrbitAnalysis DeserializeOrbitAnalysis(serialization::OrbitAnalysis const& orbit_analysis, Player::PointerMap& pointer_map, int& primary_index_storage, OrbitalElements& elements_storage, OrbitRecurrence& recurrence_storage, EquatorialCrossings& ground_track_equatorial_crossings_storage, SolarTimesOfNodes& solar_times_of_nodes_storage) {
  return {orbit_analysis.progress_of_next_analysis(),
          orbit_analysis.has_primary_index() ? [&primary_index_storage](int value) {
            primary_index_storage = value;
            return &primary_index_storage;
          }(orbit_analysis.primary_index()) : nullptr,
          orbit_analysis.mission_duration(),
          orbit_analysis.has_elements() ? [&pointer_map, &elements_storage](serialization::OrbitalElements const& message) {
            elements_storage = DeserializeOrbitalElements(message, pointer_map);
            return &elements_storage;
          }(orbit_analysis.elements()) : nullptr,
          orbit_analysis.has_recurrence() ? [&pointer_map, &recurrence_storage](serialization::OrbitRecurrence const& message) {
            recurrence_storage = DeserializeOrbitRecurrence(message, pointer_map);
            return &recurrence_storage;
          }(orbit_analysis.recurrence()) : nullptr,
          orbit_analysis.has_ground_track_equatorial_crossings() ? [&pointer_map, &ground_track_equatorial_crossings_storage](serialization::EquatorialCrossings const& message) {
            ground_track_equatorial_crossings_storage = DeserializeEquatorialCrossings(message, pointer_map);
            return &ground_track_equatorial_crossings_storage;
          }(orbit_analysis.ground_track_equatorial_crossings()) : nullptr,
          orbit_analysis.has_solar_times_of_nodes() ? [&pointer_map, &solar_times_of_nodes_storage](serialization::SolarTimesOfNodes const& message) {
            solar_times_of_nodes_storage = DeserializeSolarTimesOfNodes(message, pointer_map);
            return &solar_times_of_nodes_storage;
          }(orbit_analysis.solar_times_of_nodes()) : nullptr};
}

serialization::NavigationFrameParameters SerializeNavigationFrameParameters(NavigationFrameParameters const& navigation_frame_parameters) {
  serialization::NavigationFrameParameters m;
  m.set_extension(navigation_frame_parameters.extension);
  m.set_centre_index(navigation_frame_parameters.centre_index);
  m.set_primary_index(navigation_frame_parameters.primary_index);
  m.set_secondary_index(navigation_frame_parameters.secondary_index);
  return m;
}

serialization::XYZ SerializeXYZ(XYZ const& xyz) {
  serialization::XYZ m;
  m.set_x(xyz.x);
  m.set_y(xyz.y);
  m.set_z(xyz.z);
  return m;
}

serialization::AdaptiveStepParameters SerializeAdaptiveStepParameters(AdaptiveStepParameters const& adaptive_step_parameters) {
  serialization::AdaptiveStepParameters m;
  m.set_integrator_kind(adaptive_step_parameters.integrator_kind);
  m.set_max_steps(adaptive_step_parameters.max_steps);
  m.set_length_integration_tolerance(adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::BodyGeopotentialElement SerializeBodyGeopotentialElement(BodyGeopotentialElement const& body_geopotential_element) {
  serialization::BodyGeopotentialElement m;
  m.set_degree(body_geopotential_element.degree);
  m.set_order(body_geopotential_element.order);
  if (body_geopotential_element.cos != nullptr) {
    m.set_cos(body_geopotential_element.cos);
  }
  if (body_geopotential_element.j != nullptr) {
    m.set_j(body_geopotential_element.j);
  }
  m.set_sin(body_geopotential_element.sin);
  return m;
}

serialization::BodyParameters SerializeBodyParameters(BodyParameters const& body_parameters) {
  serialization::BodyParameters m;
  m.set_name(body_parameters.name);
  m.set_gravitational_parameter(body_parameters.gravitational_parameter);
  if (body_parameters.reference_instant != nullptr) {
    m.set_reference_instant(body_parameters.reference_instant);
  }
  if (body_parameters.min_radius != nullptr) {
    m.set_min_radius(body_parameters.min_radius);
  }
  if (body_parameters.mean_radius != nullptr) {
    m.set_mean_radius(body_parameters.mean_radius);
  }
  if (body_parameters.max_radius != nullptr) {
    m.set_max_radius(body_parameters.max_radius);
  }
  if (body_parameters.axis_right_ascension != nullptr) {
    m.set_axis_right_ascension(body_parameters.axis_right_ascension);
  }
  if (body_parameters.axis_declination != nullptr) {
    m.set_axis_declination(body_parameters.axis_declination);
  }
  if (body_parameters.reference_angle != nullptr) {
    m.set_reference_angle(body_parameters.reference_angle);
  }
  if (body_parameters.angular_frequency != nullptr) {
    m.set_angular_frequency(body_parameters.angular_frequency);
  }
  if (body_parameters.reference_radius != nullptr) {
    m.set_reference_radius(body_parameters.reference_radius);
  }
  if (body_parameters.j2 != nullptr) {
    m.set_j2(body_parameters.j2);
  }
  for (BodyGeopotentialElement const* const* geopotential = body_parameters.geopotential; geopotential != nullptr && *geopotential != nullptr; ++geopotential) {
    *m.add_geopotential() = SerializeBodyGeopotentialElement(**geopotential);
  }
  return m;
}

serialization::Burn SerializeBurn(Burn const& burn) {
  serialization::Burn m;
  m.set_thrust_in_kilonewtons(burn.thrust_in_kilonewtons);
  m.set_specific_impulse_in_seconds_g0(burn.specific_impulse_in_seconds_g0);
  *m.mutable_frame() = SerializeNavigationFrameParameters(burn.frame);
  m.set_initial_time(burn.initial_time);
  *m.mutable_delta_v() = SerializeXYZ(burn.delta_v);
  m.set_is_inertially_fixed(burn.is_inertially_fixed);
  return m;
}

serialization::ConfigurationAccuracyParameters SerializeConfigurationAccuracyParameters(ConfigurationAccuracyParameters const& configuration_accuracy_parameters) {
  serialization::ConfigurationAccuracyParameters m;
  m.set_fitting_tolerance(configuration_accuracy_parameters.fitting_tolerance);
  m.set_geopotential_tolerance(configuration_accuracy_parameters.geopotential_tolerance);
  return m;
}

serialization::ConfigurationDownsamplingParameters SerializeConfigurationDownsamplingParameters(ConfigurationDownsamplingParameters const& configuration_downsampling_parameters) {
  serialization::ConfigurationDownsamplingParameters m;
  m.set_max_dense_intervals(configuration_downsampling_parameters.max_dense_intervals);
  m.set_tolerance(configuration_downsampling_parameters.tolerance);
  return m;
}

serialization::ConfigurationFixedStepParameters SerializeConfigurationFixedStepParameters(ConfigurationFixedStepParameters const& configuration_fixed_step_parameters) {
  serialization::ConfigurationFixedStepParameters m;
  m.set_fixed_step_size_integrator(configuration_fixed_step_parameters.fixed_step_size_integrator);
  m.set_integration_step_size(configuration_fixed_step_parameters.integration_step_size);
  return m;
}

serialization::ConfigurationAdaptiveStepParameters SerializeConfigurationAdaptiveStepParameters(ConfigurationAdaptiveStepParameters const& configuration_adaptive_step_parameters) {
  serialization::ConfigurationAdaptiveStepParameters m;
  m.set_adaptive_step_size_integrator(configuration_adaptive_step_parameters.adaptive_step_size_integrator);
  m.set_length_integration_tolerance(configuration_adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(configuration_adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::FlightPlanAdaptiveStepParameters SerializeFlightPlanAdaptiveStepParameters(FlightPlanAdaptiveStepParameters const& flight_plan_adaptive_step_parameters) {
  serialization::FlightPlanAdaptiveStepParameters m;
  m.set_integrator_kind(flight_plan_adaptive_step_parameters.integrator_kind);
  m.set_generalized_integrator_kind(flight_plan_adaptive_step_parameters.generalized_integrator_kind);
  m.set_max_steps(flight_plan_adaptive_step_parameters.max_steps);
  m.set_length_integration_tolerance(flight_plan_adaptive_step_parameters.length_integration_tolerance);
  m.set_speed_integration_tolerance(flight_plan_adaptive_step_parameters.speed_integration_tolerance);
  return m;
}

serialization::KeplerianElements SerializeKeplerianElements(KeplerianElements const& keplerian_elements) {
  serialization::KeplerianElements m;
  m.set_eccentricity(keplerian_elements.eccentricity);
  m.set_semimajor_axis(keplerian_elements.semimajor_axis);
  m.set_mean_motion(keplerian_elements.mean_motion);
  m.set_inclination_in_degrees(keplerian_elements.inclination_in_degrees);
  m.set_longitude_of_ascending_node_in_degrees(keplerian_elements.longitude_of_ascending_node_in_degrees);
  m.set_argument_of_periapsis_in_degrees(keplerian_elements.argument_of_periapsis_in_degrees);
  m.set_mean_anomaly(keplerian_elements.mean_anomaly);
  return m;
}

serialization::NavigationManoeuvre SerializeNavigationManoeuvre(NavigationManoeuvre const& navigation_manoeuvre) {
  serialization::NavigationManoeuvre m;
  *m.mutable_burn() = SerializeBurn(navigation_manoeuvre.burn);
  m.set_initial_mass_in_tonnes(navigation_manoeuvre.initial_mass_in_tonnes);
  m.set_final_mass_in_tonnes(navigation_manoeuvre.final_mass_in_tonnes);
  m.set_mass_flow(navigation_manoeuvre.mass_flow);
  m.set_duration(navigation_manoeuvre.duration);
  m.set_final_time(navigation_manoeuvre.final_time);
  m.set_time_of_half_delta_v(navigation_manoeuvre.time_of_half_delta_v);
  m.set_time_to_half_delta_v(navigation_manoeuvre.time_to_half_delta_v);
  return m;
}

serialization::NavigationManoeuvreFrenetTrihedron SerializeNavigationManoeuvreFrenetTrihedron(NavigationManoeuvreFrenetTrihedron const& navigation_manoeuvre_frenet_trihedron) {
  serialization::NavigationManoeuvreFrenetTrihedron m;
  *m.mutable_binormal() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.binormal);
  *m.mutable_normal() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.normal);
  *m.mutable_tangent() = SerializeXYZ(navigation_manoeuvre_frenet_trihedron.tangent);
  return m;
}

serialization::Node SerializeNode(Node const& node) {
  serialization::Node m;
  m.set_time(node.time);
  *m.mutable_world_position() = SerializeXYZ(node.world_position);
  m.set_apparent_inclination_in_degrees(node.apparent_inclination_in_degrees);
  m.set_out_of_plane_velocity(node.out_of_plane_velocity);
  return m;
}

serialization::Origin SerializeOrigin(Origin const& origin) {
  serialization::Origin m;
  m.set_reference_part_is_at_origin(origin.reference_part_is_at_origin);
  m.set_reference_part_is_unmoving(origin.reference_part_is_unmoving);
  m.set_reference_part_id(origin.reference_part_id);
  *m.mutable_main_body_centre_in_world() = SerializeXYZ(origin.main_body_centre_in_world);
  return m;
}

serialization::PlottingFrameParameters SerializePlottingFrameParameters(PlottingFrameParameters const& plotting_frame_parameters) {
  serialization::PlottingFrameParameters m;
  m.set_extension(plotting_frame_parameters.extension);
  m.set_centre_index(plotting_frame_parameters.centre_index);
  for (int const* const* primary_index = plotting_frame_parameters.primary_index; primary_index != nullptr && *primary_index != nullptr; ++primary_index) {
    m.add_primary_index(**primary_index);
  }
  for (int const* const* secondary_index = plotting_frame_parameters.secondary_index; secondary_index != nullptr && *secondary_index != nullptr; ++secondary_index) {
    m.add_secondary_index(**secondary_index);
  }
  return m;
}

serialization::QP SerializeQP(QP const& qp) {
  serialization::QP m;
  *m.mutable_q() = SerializeXYZ(qp.q);
  *m.mutable_p() = SerializeXYZ(qp.p);
  return m;
}

serialization::TQP SerializeTQP(TQP const& tqp) {
  serialization::TQP m;
  m.set_t(tqp.t);
  *m.mutable_qp() = SerializeQP(tqp.qp);
  return m;
}

serialization::Status SerializeStatus(Status const& status) {
  serialization::Status m;
  m.set_error(status.error);
  m.set_message(SerializePointer(status.message));
  return m;
}

serialization::WXYZ SerializeWXYZ(WXYZ const& wxyz) {
  serialization::WXYZ m;
  m.set_w(wxyz.w);
  m.set_x(wxyz.x);
  m.set_y(wxyz.y);
  m.set_z(wxyz.z);
  return m;
}

serialization::QPRW SerializeQPRW(QPRW const& qprw) {
  serialization::QPRW m;
  *m.mutable_qp() = SerializeQP(qprw.qp);
  *m.mutable_r() = SerializeWXYZ(qprw.r);
  *m.mutable_w() = SerializeXYZ(qprw.w);
  return m;
}

serialization::XY SerializeXY(XY const& xy) {
  serialization::XY m;
  m.set_x(xy.x);
  m.set_y(xy.y);
  return m;
}

serialization::Interval SerializeInterval(Interval const& interval) {
  serialization::Interval m;
  m.set_min(interval.min);
  m.set_max(interval.max);
  return m;
}

serialization::OrbitalElements SerializeOrbitalElements(OrbitalElements const& orbital_elements) {
  serialization::OrbitalElements m;
  m.set_sidereal_period(orbital_elements.sidereal_period);
  m.set_nodal_period(orbital_elements.nodal_period);
  m.set_anomalistic_period(orbital_elements.anomalistic_period);
  m.set_nodal_precession(orbital_elements.nodal_precession);
  *m.mutable_mean_semimajor_axis() = SerializeInterval(orbital_elements.mean_semimajor_axis);
  *m.mutable_mean_eccentricity() = SerializeInterval(orbital_elements.mean_eccentricity);
  *m.mutable_mean_inclination() = SerializeInterval(orbital_elements.mean_inclination);
  *m.mutable_mean_longitude_of_ascending_nodes() = SerializeInterval(orbital_elements.mean_longitude_of_ascending_nodes);
  *m.mutable_mean_argument_of_periapsis() = SerializeInterval(orbital_elements.mean_argument_of_periapsis);
  *m.mutable_mean_periapsis_distance() = SerializeInterval(orbital_elements.mean_periapsis_distance);
  *m.mutable_mean_apoapsis_distance() = SerializeInterval(orbital_elements.mean_apoapsis_distance);
  *m.mutable_radial_distance() = SerializeInterval(orbital_elements.radial_distance);
  return m;
}

serialization::OrbitRecurrence SerializeOrbitRecurrence(OrbitRecurrence const& orbit_recurrence) {
  serialization::OrbitRecurrence m;
  m.set_nuo(orbit_recurrence.nuo);
  m.set_dto(orbit_recurrence.dto);
  m.set_cto(orbit_recurrence.cto);
  m.set_number_of_revolutions(orbit_recurrence.number_of_revolutions);
  m.set_equatorial_shift(orbit_recurrence.equatorial_shift);
  m.set_base_interval(orbit_recurrence.base_interval);
  m.set_grid_interval(orbit_recurrence.grid_interval);
  m.set_subcycle(orbit_recurrence.subcycle);
  return m;
}

serialization::EquatorialCrossings SerializeEquatorialCrossings(EquatorialCrossings const& equatorial_crossings) {
  serialization::EquatorialCrossings m;
  *m.mutable_longitudes_reduced_to_ascending_pass() = SerializeInterval(equatorial_crossings.longitudes_reduced_to_ascending_pass);
  *m.mutable_longitudes_reduced_to_descending_pass() = SerializeInterval(equatorial_crossings.longitudes_reduced_to_descending_pass);
  return m;
}

serialization::SolarTimesOfNodes SerializeSolarTimesOfNodes(SolarTimesOfNodes const& solar_times_of_nodes) {
  serialization::SolarTimesOfNodes m;
  *m.mutable_mean_solar_times_of_ascending_nodes() = SerializeInterval(solar_times_of_nodes.mean_solar_times_of_ascending_nodes);
  *m.mutable_mean_solar_times_of_descending_nodes() = SerializeInterval(solar_times_of_nodes.mean_solar_times_of_descending_nodes);
  return m;
}

serialization::OrbitAnalysis SerializeOrbitAnalysis(OrbitAnalysis const& orbit_analysis) {
  serialization::OrbitAnalysis m;
  m.set_progress_of_next_analysis(orbit_analysis.progress_of_next_analysis);
  if (orbit_analysis.primary_index != nullptr) {
    m.set_primary_index(*orbit_analysis.primary_index);
  }
  m.set_mission_duration(orbit_analysis.mission_duration);
  if (orbit_analysis.elements != nullptr) {
    *m.mutable_elements() = SerializeOrbitalElements(*orbit_analysis.elements);
  }
  if (orbit_analysis.recurrence != nullptr) {
    *m.mutable_recurrence() = SerializeOrbitRecurrence(*orbit_analysis.recurrence);
  }
  if (orbit_analysis.ground_track_equatorial_crossings != nullptr) {
    *m.mutable_ground_track_equatorial_crossings() = SerializeEquatorialCrossings(*orbit_analysis.ground_track_equatorial_crossings);
  }
  if (orbit_analysis.solar_times_of_nodes != nullptr) {
    *m.mutable_solar_times_of_nodes() = SerializeSolarTimesOfNodes(*orbit_analysis.solar_times_of_nodes);
  }
  m.set_primary_index_address(SerializePointer(orbit_analysis.primary_index));
  m.set_elements_address(SerializePointer(orbit_analysis.elements));
  m.set_recurrence_address(SerializePointer(orbit_analysis.recurrence));
  m.set_ground_track_equatorial_crossings_address(SerializePointer(orbit_analysis.ground_track_equatorial_crossings));
  m.set_solar_times_of_nodes_address(SerializePointer(orbit_analysis.solar_times_of_nodes));
  return m;
}

void InsertStatus(serialization::Status const& status_proto, Status const& status_object, Player::PointerMap& pointer_map) {
  Insert(status_proto.message(), status_object.message, pointer_map);
}

void InsertOrbitAnalysis(serialization::OrbitAnalysis const& orbit_analysis_proto, OrbitAnalysis const& orbit_analysis_object, Player::PointerMap& pointer_map) {
  Insert(orbit_analysis_proto.primary_index_address(), orbit_analysis_object.primary_index, pointer_map);
  Insert(orbit_analysis_proto.elements_address(), orbit_analysis_object.elements, pointer_map);
  Insert(orbit_analysis_proto.recurrence_address(), orbit_analysis_object.recurrence, pointer_map);
  Insert(orbit_analysis_proto.ground_track_equatorial_crossings_address(), orbit_analysis_object.ground_track_equatorial_crossings, pointer_map);
  Insert(orbit_analysis_proto.solar_times_of_nodes_address(), orbit_analysis_object.solar_times_of_nodes, pointer_map);
}

}  // namespace

void AdvanceTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
  m->set_planetarium_rotation(in.planetarium_rotation);
}

void AdvanceTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto t = in.t();
  auto planetarium_rotation = in.planetarium_rotation();
  interface::principia__AdvanceTime(plugin, t, planetarium_rotation);
}

void AngularMomentumFromAngularVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  *m->mutable_world_angular_velocity() = SerializeXYZ(in.world_angular_velocity);
  *m->mutable_moments_of_inertia_in_tonnes() = SerializeXYZ(in.moments_of_inertia_in_tonnes);
  *m->mutable_principal_axes_rotation() = SerializeWXYZ(in.principal_axes_rotation);
  *m->mutable_part_rotation() = SerializeWXYZ(in.part_rotation);
}

void AngularMomentumFromAngularVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void AngularMomentumFromAngularVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto world_angular_velocity = DeserializeXYZ(in.world_angular_velocity(), pointer_map);
  auto moments_of_inertia_in_tonnes = DeserializeXYZ(in.moments_of_inertia_in_tonnes(), pointer_map);
  auto principal_axes_rotation = DeserializeWXYZ(in.principal_axes_rotation(), pointer_map);
  auto part_rotation = DeserializeWXYZ(in.part_rotation(), pointer_map);
  auto const result = interface::principia__AngularMomentumFromAngularVelocity(world_angular_velocity, moments_of_inertia_in_tonnes, principal_axes_rotation, part_rotation);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void CameraReferenceRotation::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CameraReferenceRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CameraReferenceRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto const result = interface::principia__CameraReferenceRotation(plugin);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result(), pointer_map), result);
}

void CameraScale::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CameraScale::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CameraScale::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto const result = interface::principia__CameraScale(plugin);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CatchUpLaggingVessels::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CatchUpLaggingVessels::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_collided_vessels(SerializePointer(*out.collided_vessels));
}

void CatchUpLaggingVessels::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  Iterator* collided_vessels;
  interface::principia__CatchUpLaggingVessels(plugin, &collided_vessels);
  Insert(out.collided_vessels(), collided_vessels, pointer_map);
}

void CelestialFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialFromParent::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialFromParent(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result(), pointer_map), result);
}

void CelestialInitialRotationInDegrees::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialInitialRotationInDegrees::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CelestialInitialRotationInDegrees::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialInitialRotationInDegrees(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CelestialRotation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void CelestialRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CelestialRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto index = in.index();
  auto const result = interface::principia__CelestialRotation(plugin, index);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result(), pointer_map), result);
}

void CelestialRotationPeriod::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialRotationPeriod::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CelestialRotationPeriod::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialRotationPeriod(plugin, celestial_index);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CelestialSphereRotation::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CelestialSphereRotation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void CelestialSphereRotation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto const result = interface::principia__CelestialSphereRotation(plugin);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result(), pointer_map), result);
}

void CelestialWorldDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
  *m->mutable_origin() = SerializeOrigin(in.origin);
  m->set_time(in.time);
}

void CelestialWorldDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialWorldDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto index = in.index();
  auto origin = DeserializeOrigin(in.origin(), pointer_map);
  auto time = in.time();
  auto const result = interface::principia__CelestialWorldDegreesOfFreedom(plugin, index, origin, time);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result(), pointer_map), result);
}

void CollisionDeleteExecutor::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_executor(SerializePointer(*in.executor));
}

void CollisionDeleteExecutor::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_executor(SerializePointer(*out.executor));
  *m->mutable_collision() = SerializeTQP(*out.collision);
}

void CollisionDeleteExecutor::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_found(result);
}

void CollisionDeleteExecutor::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto executor = DeserializePointer<PushPullExecutor<std::optional<DiscreteTrajectory<World>::value_type>, Length, Angle, Angle>*>(in.executor(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  TQP collision;
  auto const result = interface::principia__CollisionDeleteExecutor(plugin, &executor, &collision);
  Delete(in.executor(), pointer_map);
  PRINCIPIA_CHECK_EQ(message.return_().found(), result);
}

void CollisionGetLatitudeLongitude::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_executor(SerializePointer(in.executor));
}

void CollisionGetLatitudeLongitude::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_latitude_in_degrees(*out.latitude_in_degrees);
  m->set_longitude_in_degrees(*out.longitude_in_degrees);
}

void CollisionGetLatitudeLongitude::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CollisionGetLatitudeLongitude::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto executor = DeserializePointer<PushPullExecutor<std::optional<DiscreteTrajectory<World>::value_type>, Length, Angle, Angle>*>(in.executor(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  double latitude_in_degrees;
  double longitude_in_degrees;
  auto const result = interface::principia__CollisionGetLatitudeLongitude(executor, &latitude_in_degrees, &longitude_in_degrees);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void CollisionNewFlightPlanExecutor::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
  m->set_vessel_guid(in.vessel_guid);
}

void CollisionNewFlightPlanExecutor::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void CollisionNewFlightPlanExecutor::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__CollisionNewFlightPlanExecutor(plugin, celestial_index, sun_world_position, max_points, vessel_guid);
  Insert(message.return_().result(), result, pointer_map);
}

void CollisionNewPredictionExecutor::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
  m->set_vessel_guid(in.vessel_guid);
}

void CollisionNewPredictionExecutor::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void CollisionNewPredictionExecutor::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__CollisionNewPredictionExecutor(plugin, celestial_index, sun_world_position, max_points, vessel_guid);
  Insert(message.return_().result(), result, pointer_map);
}

void CollisionSetRadius::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_executor(SerializePointer(in.executor));
  m->set_radius(in.radius);
}

void CollisionSetRadius::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto executor = DeserializePointer<PushPullExecutor<std::optional<DiscreteTrajectory<World>::value_type>, Length, Angle, Angle>*>(in.executor(), pointer_map);
  auto radius = in.radius();
  interface::principia__CollisionSetRadius(executor, radius);
}

void ClearFlags::Run(Message const& message, Player::PointerMap& pointer_map) {
  interface::principia__ClearFlags();
}

void ClearTargetVessel::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void ClearTargetVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  interface::principia__ClearTargetVessel(plugin);
}

void ClearWorldRotationalReferenceFrame::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void ClearWorldRotationalReferenceFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  interface::principia__ClearWorldRotationalReferenceFrame(plugin);
}

void CurrentTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CurrentTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CurrentTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto const result = interface::principia__CurrentTime(plugin);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void DeleteInterchange::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_pointer(SerializePointer(*in.native_pointer));
}

void DeleteInterchange::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_pointer(SerializePointer(*out.native_pointer));
}

void DeleteInterchange::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto native_pointer = DeserializePointer<void const*>(in.native_pointer(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeleteInterchange(&native_pointer);
  Delete(in.native_pointer(), pointer_map);
}

void DeletePlugin::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(*in.plugin));
}

void DeletePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_plugin(SerializePointer(*out.plugin));
}

void DeletePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeletePlugin(&plugin);
  Delete(in.plugin(), pointer_map);
}

void DeleteString::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_string(SerializePointer(*in.native_string));
}

void DeleteString::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_string(SerializePointer(*out.native_string));
}

void DeleteString::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto native_string = DeserializePointer<char const*>(in.native_string(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeleteString(&native_string);
  Delete(in.native_string(), pointer_map);
}

void DeleteU16String::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_native_string(SerializePointer(*in.native_string));
}

void DeleteU16String::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_native_string(SerializePointer(*out.native_string));
}

void DeleteU16String::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto native_string = DeserializePointer<char16_t const*>(in.native_string(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeleteU16String(&native_string);
  Delete(in.native_string(), pointer_map);
}

void DeserializePlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_serialization(in.serialization);
  m->set_deserializer(SerializePointer(*in.deserializer));
  m->set_plugin(SerializePointer(*in.plugin));
  m->set_compressor(in.compressor);
  m->set_encoder(in.encoder);
}

void DeserializePlugin::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_deserializer(SerializePointer(*out.deserializer));
  m->set_plugin(SerializePointer(*out.plugin));
}

void DeserializePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto serialization = in.serialization().c_str();
  auto deserializer = DeserializePointer<PushDeserializer*>(in.deserializer(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto compressor = in.compressor().c_str();
  auto encoder = in.encoder().c_str();
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__DeserializePlugin(serialization, &deserializer, &plugin, compressor, encoder);
  if (std::string_view(serialization).empty()) {
    Delete(in.deserializer(), pointer_map);
  }
  if (!std::string_view(serialization).empty()) {
    Insert(out.deserializer(), deserializer, pointer_map);
  }
  Insert(out.plugin(), plugin, pointer_map);
}

void EndInitialization::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void EndInitialization::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  interface::principia__EndInitialization(plugin);
}

void EquipotentialCount::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void EquipotentialCount::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void EquipotentialCount::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto const result = interface::principia__EquipotentialCount(plugin);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void ExternalCelestialGetPosition::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_body_index(in.body_index);
  m->set_time(in.time);
}

void ExternalCelestialGetPosition::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_position() = SerializeXYZ(*out.position);
}

void ExternalCelestialGetPosition::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalCelestialGetPosition::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto body_index = in.body_index();
  auto time = in.time();
  [[maybe_unused]] auto const& out = message.out();
  XYZ position;
  auto const result = interface::principia__ExternalCelestialGetPosition(plugin, body_index, time, &position);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void ExternalCelestialGetSurfacePosition::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_body_index(in.body_index);
  m->set_planetocentric_latitude_in_degrees(in.planetocentric_latitude_in_degrees);
  m->set_planetocentric_longitude_in_degrees(in.planetocentric_longitude_in_degrees);
  m->set_radius(in.radius);
  m->set_time(in.time);
}

void ExternalCelestialGetSurfacePosition::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_position() = SerializeXYZ(*out.position);
}

void ExternalCelestialGetSurfacePosition::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalCelestialGetSurfacePosition::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto body_index = in.body_index();
  auto planetocentric_latitude_in_degrees = in.planetocentric_latitude_in_degrees();
  auto planetocentric_longitude_in_degrees = in.planetocentric_longitude_in_degrees();
  auto radius = in.radius();
  auto time = in.time();
  [[maybe_unused]] auto const& out = message.out();
  XYZ position;
  auto const result = interface::principia__ExternalCelestialGetSurfacePosition(plugin, body_index, planetocentric_latitude_in_degrees, planetocentric_longitude_in_degrees, radius, time, &position);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void ExternalFlowFreefall::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_central_body_index(in.central_body_index);
  *m->mutable_world_body_centred_initial_degrees_of_freedom() = SerializeQP(in.world_body_centred_initial_degrees_of_freedom);
  m->set_t_initial(in.t_initial);
  m->set_t_final(in.t_final);
}

void ExternalFlowFreefall::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_world_body_centred_final_degrees_of_freedom() = SerializeQP(*out.world_body_centred_final_degrees_of_freedom);
}

void ExternalFlowFreefall::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalFlowFreefall::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto central_body_index = in.central_body_index();
  auto world_body_centred_initial_degrees_of_freedom = DeserializeQP(in.world_body_centred_initial_degrees_of_freedom(), pointer_map);
  auto t_initial = in.t_initial();
  auto t_final = in.t_final();
  [[maybe_unused]] auto const& out = message.out();
  QP world_body_centred_final_degrees_of_freedom;
  auto const result = interface::principia__ExternalFlowFreefall(plugin, central_body_index, world_body_centred_initial_degrees_of_freedom, t_initial, t_final, &world_body_centred_final_degrees_of_freedom);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void ExternalGeopotentialGetCoefficient::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_body_index(in.body_index);
  m->set_degree(in.degree);
  m->set_order(in.order);
}

void ExternalGeopotentialGetCoefficient::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_coefficient() = SerializeXY(*out.coefficient);
}

void ExternalGeopotentialGetCoefficient::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalGeopotentialGetCoefficient::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto body_index = in.body_index();
  auto degree = in.degree();
  auto order = in.order();
  [[maybe_unused]] auto const& out = message.out();
  XY coefficient;
  auto const result = interface::principia__ExternalGeopotentialGetCoefficient(plugin, body_index, degree, order, &coefficient);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void ExternalGeopotentialGetReferenceRadius::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_body_index(in.body_index);
}

void ExternalGeopotentialGetReferenceRadius::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_reference_radius(*out.reference_radius);
}

void ExternalGeopotentialGetReferenceRadius::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalGeopotentialGetReferenceRadius::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto body_index = in.body_index();
  [[maybe_unused]] auto const& out = message.out();
  double reference_radius;
  auto const result = interface::principia__ExternalGeopotentialGetReferenceRadius(plugin, body_index, &reference_radius);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void ExternalVesselGetPosition::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_time(in.time);
}

void ExternalVesselGetPosition::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_position() = SerializeXYZ(*out.position);
}

void ExternalVesselGetPosition::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalVesselGetPosition::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto time = in.time();
  [[maybe_unused]] auto const& out = message.out();
  XYZ position;
  auto const result = interface::principia__ExternalVesselGetPosition(plugin, vessel_guid, time, &position);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_central_body_index(in.central_body_index);
  m->set_vessel_guid(in.vessel_guid);
  m->set_manoeuvre_index(in.manoeuvre_index);
  *m->mutable_world_body_centred_reference_position() = SerializeXYZ(in.world_body_centred_reference_position);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(Out const& out, not_null<Message*> const message) {
  *message->mutable_out()->mutable_world_body_centred_nearest_degrees_of_freedom() = SerializeQP(*out.world_body_centred_nearest_degrees_of_freedom);
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void ExternalGetNearestPlannedCoastDegreesOfFreedom::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto central_body_index = in.central_body_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto manoeuvre_index = in.manoeuvre_index();
  auto world_body_centred_reference_position = DeserializeXYZ(in.world_body_centred_reference_position(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  QP world_body_centred_nearest_degrees_of_freedom;
  auto const result = interface::principia__ExternalGetNearestPlannedCoastDegreesOfFreedom(plugin, central_body_index, vessel_guid, manoeuvre_index, world_body_centred_reference_position, &world_body_centred_nearest_degrees_of_freedom);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanCount::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanCount::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanCount::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanCount(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
}

void FlightPlanCreate::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto mass_in_tonnes = in.mass_in_tonnes();
  interface::principia__FlightPlanCreate(plugin, vessel_guid, final_time, mass_in_tonnes);
}

void FlightPlanDelete::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanDelete(plugin, vessel_guid);
}

void FlightPlanDuplicate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanDuplicate::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanDuplicate(plugin, vessel_guid);
}

void FlightPlanExists::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanExists::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanExists::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanExists(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeFlightPlanAdaptiveStepParameters(result);
}

void FlightPlanGetAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetAdaptiveStepParameters(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeFlightPlanAdaptiveStepParameters(message.return_().result(), pointer_map), result);
}

void FlightPlanGetActualFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetActualFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetActualFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetActualFinalTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetAnomalousStatus::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetAnomalousStatus::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanGetAnomalousStatus::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetAnomalousStatus(plugin, vessel_guid);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanGetCoastAnalysis::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.revolutions_per_cycle != nullptr) {
    m->set_revolutions_per_cycle(*in.revolutions_per_cycle);
  }
  if (in.days_per_cycle != nullptr) {
    m->set_days_per_cycle(*in.days_per_cycle);
  }
  m->set_ground_track_revolution(in.ground_track_revolution);
  m->set_index(in.index);
}

void FlightPlanGetCoastAnalysis::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeOrbitAnalysis(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanGetCoastAnalysis::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  int revolutions_per_cycle_storage;
  auto revolutions_per_cycle = in.has_revolutions_per_cycle() ? [&revolutions_per_cycle_storage](int value) {
            revolutions_per_cycle_storage = value;
            return &revolutions_per_cycle_storage;
          }(in.revolutions_per_cycle()) : nullptr;
  int days_per_cycle_storage;
  auto days_per_cycle = in.has_days_per_cycle() ? [&days_per_cycle_storage](int value) {
            days_per_cycle_storage = value;
            return &days_per_cycle_storage;
          }(in.days_per_cycle()) : nullptr;
  auto ground_track_revolution = in.ground_track_revolution();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetCoastAnalysis(plugin, vessel_guid, revolutions_per_cycle, days_per_cycle, ground_track_revolution, index);
  InsertOrbitAnalysis(message.return_().result(), *result, pointer_map);
  int primary_index_storage;
  OrbitalElements elements_storage;
  OrbitRecurrence recurrence_storage;
  EquatorialCrossings ground_track_equatorial_crossings_storage;
  SolarTimesOfNodes solar_times_of_nodes_storage;
  PRINCIPIA_CHECK_EQ(DeserializeOrbitAnalysis(message.return_().result(), pointer_map, primary_index_storage, elements_storage, recurrence_storage, ground_track_equatorial_crossings_storage, solar_times_of_nodes_storage), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanGetDesiredFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetDesiredFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetDesiredFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetDesiredFinalTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetGuidance::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetGuidance::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void FlightPlanGetGuidance::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetGuidance(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void FlightPlanGetInitialTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanGetInitialTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanGetInitialTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanGetInitialTime(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanGetManoeuvre::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvre::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvre(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanGetManoeuvre::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvre(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeNavigationManoeuvre(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvreFrenetTrihedron(result);
}

void FlightPlanGetManoeuvreFrenetTrihedron::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvreFrenetTrihedron(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeNavigationManoeuvreFrenetTrihedron(message.return_().result(), pointer_map), result);
}

void FlightPlanGetManoeuvreInitialPlottedVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvreInitialPlottedVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void FlightPlanGetManoeuvreInitialPlottedVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvreInitialPlottedVelocity(plugin, vessel_guid, index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void FlightPlanInsert::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
  m->set_index(in.index);
}

void FlightPlanInsert::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanInsert::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn(), pointer_map);
  auto index = in.index();
  auto const result = interface::principia__FlightPlanInsert(plugin, vessel_guid, burn, index);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanNumberOfAnomalousManoeuvres::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfAnomalousManoeuvres::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfAnomalousManoeuvres::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfAnomalousManoeuvres(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanNumberOfManoeuvres::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfManoeuvres::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfManoeuvres::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfManoeuvres(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanNumberOfSegments::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfSegments::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfSegments::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfSegments(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanOptimizationDriverInProgress::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanOptimizationDriverInProgress::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_manoeuvre_index(result);
}

void FlightPlanOptimizationDriverInProgress::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanOptimizationDriverInProgress(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().manoeuvre_index(), result);
}

void FlightPlanOptimizationDriverMake::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_distance(in.distance);
  if (in.inclination_in_degrees != nullptr) {
    m->set_inclination_in_degrees(*in.inclination_in_degrees);
  }
  m->set_celestial_index(in.celestial_index);
  *m->mutable_navigation_frame_parameters() = SerializeNavigationFrameParameters(in.navigation_frame_parameters);
}

void FlightPlanOptimizationDriverMake::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto distance = in.distance();
  double inclination_in_degrees_storage;
  auto inclination_in_degrees = in.has_inclination_in_degrees() ? [&inclination_in_degrees_storage](double value) {
            inclination_in_degrees_storage = value;
            return &inclination_in_degrees_storage;
          }(in.inclination_in_degrees()) : nullptr;
  auto celestial_index = in.celestial_index();
  auto navigation_frame_parameters = DeserializeNavigationFrameParameters(in.navigation_frame_parameters(), pointer_map);
  interface::principia__FlightPlanOptimizationDriverMake(plugin, vessel_guid, distance, inclination_in_degrees, celestial_index, navigation_frame_parameters);
}

void FlightPlanOptimizationDriverStart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_manoeuvre_index(in.manoeuvre_index);
}

void FlightPlanOptimizationDriverStart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto manoeuvre_index = in.manoeuvre_index();
  interface::principia__FlightPlanOptimizationDriverStart(plugin, vessel_guid, manoeuvre_index);
}

void FlightPlanRebase::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
}

void FlightPlanRebase::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanRebase::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto mass_in_tonnes = in.mass_in_tonnes();
  auto const result = interface::principia__FlightPlanRebase(plugin, vessel_guid, mass_in_tonnes);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanRemove::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanRemove::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanRemove::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanRemove(plugin, vessel_guid, index);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanRenderedApsides::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void FlightPlanRenderedApsides::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_apoapsides(SerializePointer(*out.apoapsides));
  m->set_periapsides(SerializePointer(*out.periapsides));
}

void FlightPlanRenderedApsides::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* apoapsides;
  Iterator* periapsides;
  interface::principia__FlightPlanRenderedApsides(plugin, vessel_guid, t_max, celestial_index, sun_world_position, max_points, &apoapsides, &periapsides);
  Insert(out.apoapsides(), apoapsides, pointer_map);
  Insert(out.periapsides(), periapsides, pointer_map);
}

void FlightPlanRenderedClosestApproaches::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void FlightPlanRenderedClosestApproaches::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_closest_approaches(SerializePointer(*out.closest_approaches));
}

void FlightPlanRenderedClosestApproaches::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* closest_approaches;
  interface::principia__FlightPlanRenderedClosestApproaches(plugin, vessel_guid, sun_world_position, max_points, &closest_approaches);
  Insert(out.closest_approaches(), closest_approaches, pointer_map);
}

void FlightPlanRenderedNodes::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void FlightPlanRenderedNodes::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_ascending(SerializePointer(*out.ascending));
  m->set_descending(SerializePointer(*out.descending));
}

void FlightPlanRenderedNodes::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* ascending;
  Iterator* descending;
  interface::principia__FlightPlanRenderedNodes(plugin, vessel_guid, t_max, sun_world_position, max_points, &ascending, &descending);
  Insert(out.ascending(), ascending, pointer_map);
  Insert(out.descending(), descending, pointer_map);
}

void FlightPlanRenderedSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_index(in.index);
}

void FlightPlanRenderedSegment::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FlightPlanRenderedSegment::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto index = in.index();
  auto const result = interface::principia__FlightPlanRenderedSegment(plugin, vessel_guid, sun_world_position, index);
  Insert(message.return_().result(), result, pointer_map);
}

void FlightPlanReplace::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
  m->set_index(in.index);
}

void FlightPlanReplace::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanReplace::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn(), pointer_map);
  auto index = in.index();
  auto const result = interface::principia__FlightPlanReplace(plugin, vessel_guid, burn, index);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanSelect::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanSelect::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  interface::principia__FlightPlanSelect(plugin, vessel_guid, index);
}

void FlightPlanSelected::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanSelected::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanSelected::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanSelected(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FlightPlanSetAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_flight_plan_adaptive_step_parameters() = SerializeFlightPlanAdaptiveStepParameters(in.flight_plan_adaptive_step_parameters);
}

void FlightPlanSetAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanSetAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto flight_plan_adaptive_step_parameters = DeserializeFlightPlanAdaptiveStepParameters(in.flight_plan_adaptive_step_parameters(), pointer_map);
  auto const result = interface::principia__FlightPlanSetAdaptiveStepParameters(plugin, vessel_guid, flight_plan_adaptive_step_parameters);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanSetDesiredFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
}

void FlightPlanSetDesiredFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void FlightPlanSetDesiredFinalTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto const result = interface::principia__FlightPlanSetDesiredFinalTime(plugin, vessel_guid, final_time);
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void FlightPlanUpdateFromOptimization::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanUpdateFromOptimization::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanUpdateFromOptimization::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanUpdateFromOptimization(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void FreeVesselsAndPartsAndCollectPileUps::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_delta_t(in.delta_t);
}

void FreeVesselsAndPartsAndCollectPileUps::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto delta_t = in.delta_t();
  interface::principia__FreeVesselsAndPartsAndCollectPileUps(plugin, delta_t);
}

void FutureCatchUpVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FutureCatchUpVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FutureCatchUpVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FutureCatchUpVessel(plugin, vessel_guid);
  Insert(message.return_().result(), result, pointer_map);
}

void FutureWaitForVesselToCatchUp::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_future(SerializePointer(*in.future));
}

void FutureWaitForVesselToCatchUp::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_future(SerializePointer(*out.future));
  m->set_collided_vessels(SerializePointer(*out.collided_vessels));
}

void FutureWaitForVesselToCatchUp::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto future = DeserializePointer<PileUpFuture*>(in.future(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  Iterator* collided_vessels;
  interface::principia__FutureWaitForVesselToCatchUp(plugin, &future, &collided_vessels);
  Delete(in.future(), pointer_map);
  Insert(out.collided_vessels(), collided_vessels, pointer_map);
}

void GetBufferDuration::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferDuration::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetBufferDuration();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetBufferedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetBufferedLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetStderrLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetStderrLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetStderrLogging();
}

void GetSuppressedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetSuppressedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetSuppressedLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetVerboseLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetVerboseLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__GetVerboseLogging();
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void GetVersion::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_build_date(*out.build_date);
  m->set_version(*out.version);
}

void GetVersion::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& out = message.out();
  char const* build_date;
  char const* version;
  interface::principia__GetVersion(&build_date, &version);
}

void HasEncounteredApocalypse::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void HasEncounteredApocalypse::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_details(SerializePointer(*out.details));
}

void HasEncounteredApocalypse::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasEncounteredApocalypse::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  char const* details;
  auto const result = interface::principia__HasEncounteredApocalypse(plugin, &details);
  Insert(out.details(), details, pointer_map);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void HasVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void HasVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__HasVessel(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void InitializeDownsamplingParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_downsampling_parameters() = SerializeConfigurationDownsamplingParameters(in.downsampling_parameters);
}

void InitializeDownsamplingParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto downsampling_parameters = DeserializeConfigurationDownsamplingParameters(in.downsampling_parameters(), pointer_map);
  interface::principia__InitializeDownsamplingParameters(plugin, downsampling_parameters);
}

void InitializeEphemerisParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_accuracy_parameters() = SerializeConfigurationAccuracyParameters(in.accuracy_parameters);
  *m->mutable_fixed_step_parameters() = SerializeConfigurationFixedStepParameters(in.fixed_step_parameters);
}

void InitializeEphemerisParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto accuracy_parameters = DeserializeConfigurationAccuracyParameters(in.accuracy_parameters(), pointer_map);
  auto fixed_step_parameters = DeserializeConfigurationFixedStepParameters(in.fixed_step_parameters(), pointer_map);
  interface::principia__InitializeEphemerisParameters(plugin, accuracy_parameters, fixed_step_parameters);
}

void InitializeHistoryParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_fixed_step_parameters() = SerializeConfigurationFixedStepParameters(in.fixed_step_parameters);
}

void InitializeHistoryParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto fixed_step_parameters = DeserializeConfigurationFixedStepParameters(in.fixed_step_parameters(), pointer_map);
  interface::principia__InitializeHistoryParameters(plugin, fixed_step_parameters);
}

void InitializePsychohistoryParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeConfigurationAdaptiveStepParameters(in.parameters);
}

void InitializePsychohistoryParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto parameters = DeserializeConfigurationAdaptiveStepParameters(in.parameters(), pointer_map);
  interface::principia__InitializePsychohistoryParameters(plugin, parameters);
}

void InsertCelestialAbsoluteCartesian::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  *m->mutable_body_parameters() = SerializeBodyParameters(in.body_parameters);
  m->set_x(in.x);
  m->set_y(in.y);
  m->set_z(in.z);
  m->set_vx(in.vx);
  m->set_vy(in.vy);
  m->set_vz(in.vz);
}

void InsertCelestialAbsoluteCartesian::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  int parent_index_storage;
  auto parent_index = in.has_parent_index() ? [&parent_index_storage](int value) {
            parent_index_storage = value;
            return &parent_index_storage;
          }(in.parent_index()) : nullptr;
  std::pair<std::vector<BodyGeopotentialElement>, std::vector<BodyGeopotentialElement const*>> geopotential_storage;
  auto body_parameters = DeserializeBodyParameters(in.body_parameters(), pointer_map, geopotential_storage);
  auto x = in.x().c_str();
  auto y = in.y().c_str();
  auto z = in.z().c_str();
  auto vx = in.vx().c_str();
  auto vy = in.vy().c_str();
  auto vz = in.vz().c_str();
  interface::principia__InsertCelestialAbsoluteCartesian(plugin, celestial_index, parent_index, body_parameters, x, y, z, vx, vy, vz);
}

void InsertCelestialJacobiKeplerian::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  *m->mutable_body_parameters() = SerializeBodyParameters(in.body_parameters);
  if (in.keplerian_elements != nullptr) {
    *m->mutable_keplerian_elements() = SerializeKeplerianElements(*in.keplerian_elements);
  }
}

void InsertCelestialJacobiKeplerian::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  int parent_index_storage;
  auto parent_index = in.has_parent_index() ? [&parent_index_storage](int value) {
            parent_index_storage = value;
            return &parent_index_storage;
          }(in.parent_index()) : nullptr;
  std::pair<std::vector<BodyGeopotentialElement>, std::vector<BodyGeopotentialElement const*>> geopotential_storage;
  auto body_parameters = DeserializeBodyParameters(in.body_parameters(), pointer_map, geopotential_storage);
  KeplerianElements keplerian_elements_storage;
  auto keplerian_elements = in.has_keplerian_elements() ? [&pointer_map, &keplerian_elements_storage](serialization::KeplerianElements const& message) {
            keplerian_elements_storage = DeserializeKeplerianElements(message, pointer_map);
            return &keplerian_elements_storage;
          }(in.keplerian_elements()) : nullptr;
  interface::principia__InsertCelestialJacobiKeplerian(plugin, celestial_index, parent_index, body_parameters, keplerian_elements);
}

void InsertOrKeepVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_vessel_name(in.vessel_name);
  m->set_parent_index(in.parent_index);
  m->set_loaded(in.loaded);
}

void InsertOrKeepVessel::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_inserted(*out.inserted);
}

void InsertOrKeepVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto vessel_name = in.vessel_name().c_str();
  auto parent_index = in.parent_index();
  auto loaded = in.loaded();
  [[maybe_unused]] auto const& out = message.out();
  bool inserted;
  interface::principia__InsertOrKeepVessel(plugin, vessel_guid, vessel_name, parent_index, loaded, &inserted);
}

void InsertOrKeepLoadedPart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  m->set_name(in.name);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
  *m->mutable_centre_of_mass() = SerializeXYZ(in.centre_of_mass);
  *m->mutable_moments_of_inertia_in_tonnes() = SerializeXYZ(in.moments_of_inertia_in_tonnes);
  *m->mutable_principal_axes_rotation() = SerializeWXYZ(in.principal_axes_rotation);
  m->set_is_solid_rocket_motor(in.is_solid_rocket_motor);
  m->set_vessel_guid(in.vessel_guid);
  m->set_main_body_index(in.main_body_index);
  *m->mutable_main_body_world_degrees_of_freedom() = SerializeQP(in.main_body_world_degrees_of_freedom);
  *m->mutable_part_world_degrees_of_freedom() = SerializeQP(in.part_world_degrees_of_freedom);
  *m->mutable_part_rotation() = SerializeWXYZ(in.part_rotation);
  *m->mutable_part_angular_velocity() = SerializeXYZ(in.part_angular_velocity);
  m->set_delta_t(in.delta_t);
}

void InsertOrKeepLoadedPart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto name = in.name().c_str();
  auto mass_in_tonnes = in.mass_in_tonnes();
  auto centre_of_mass = DeserializeXYZ(in.centre_of_mass(), pointer_map);
  auto moments_of_inertia_in_tonnes = DeserializeXYZ(in.moments_of_inertia_in_tonnes(), pointer_map);
  auto principal_axes_rotation = DeserializeWXYZ(in.principal_axes_rotation(), pointer_map);
  auto is_solid_rocket_motor = in.is_solid_rocket_motor();
  auto vessel_guid = in.vessel_guid().c_str();
  auto main_body_index = in.main_body_index();
  auto main_body_world_degrees_of_freedom = DeserializeQP(in.main_body_world_degrees_of_freedom(), pointer_map);
  auto part_world_degrees_of_freedom = DeserializeQP(in.part_world_degrees_of_freedom(), pointer_map);
  auto part_rotation = DeserializeWXYZ(in.part_rotation(), pointer_map);
  auto part_angular_velocity = DeserializeXYZ(in.part_angular_velocity(), pointer_map);
  auto delta_t = in.delta_t();
  interface::principia__InsertOrKeepLoadedPart(plugin, part_id, name, mass_in_tonnes, centre_of_mass, moments_of_inertia_in_tonnes, principal_axes_rotation, is_solid_rocket_motor, vessel_guid, main_body_index, main_body_world_degrees_of_freedom, part_world_degrees_of_freedom, part_rotation, part_angular_velocity, delta_t);
}

void InsertUnloadedPart::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  m->set_name(in.name);
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_from_parent() = SerializeQP(in.from_parent);
}

void InsertUnloadedPart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto name = in.name().c_str();
  auto vessel_guid = in.vessel_guid().c_str();
  auto from_parent = DeserializeQP(in.from_parent(), pointer_map);
  interface::principia__InsertUnloadedPart(plugin, part_id, name, vessel_guid, from_parent);
}

void IteratorAtEnd::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorAtEnd::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorAtEnd::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorAtEnd(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IteratorDelete::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(*in.iterator));
}

void IteratorDelete::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_iterator(SerializePointer(*out.iterator));
}

void IteratorDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(in.iterator(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__IteratorDelete(&iterator);
  Delete(in.iterator(), pointer_map);
}

void IteratorGetDiscreteTrajectoryQP::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryQP::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void IteratorGetDiscreteTrajectoryQP::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryQP(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result(), pointer_map), result);
}

void IteratorGetDiscreteTrajectoryTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorGetDiscreteTrajectoryTime::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryTime(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void IteratorGetDiscreteTrajectoryXYZ::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetDiscreteTrajectoryXYZ::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void IteratorGetDiscreteTrajectoryXYZ::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetDiscreteTrajectoryXYZ(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void IteratorGetNode::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetNode::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_node() = SerializeNode(result);
}

void IteratorGetNode::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetNode(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeNode(message.return_().node(), pointer_map), result);
}

void IteratorGetRP2LinesIterator::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetRP2LinesIterator::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void IteratorGetRP2LinesIterator::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetRP2LinesIterator(iterator);
  Insert(message.return_().result(), result, pointer_map);
}

void IteratorGetRP2LineXY::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetRP2LineXY::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXY(result);
}

void IteratorGetRP2LineXY::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetRP2LineXY(iterator);
  PRINCIPIA_CHECK_EQ(DeserializeXY(message.return_().result(), pointer_map), result);
}

void IteratorGetVesselGuid::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorGetVesselGuid::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorGetVesselGuid::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorGetVesselGuid(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result().c_str(), result);
}

void IteratorIncrement::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorIncrement::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(in.iterator(), pointer_map);
  interface::principia__IteratorIncrement(iterator);
}

void IteratorReset::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorReset::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator*>(in.iterator(), pointer_map);
  interface::principia__IteratorReset(iterator);
}

void IteratorSize::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_iterator(SerializePointer(in.iterator));
}

void IteratorSize::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void IteratorSize::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto iterator = DeserializePointer<Iterator const*>(in.iterator(), pointer_map);
  auto const result = interface::principia__IteratorSize(iterator);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void LogError::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogError::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogError(file, line, text);
}

void LogFatal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogFatal::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogFatal(file, line, text);
}

void LogInfo::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogInfo::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogInfo(file, line, text);
}

void LogWarning::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_file(in.file);
  m->set_line(in.line);
  m->set_text(in.text);
}

void LogWarning::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto file = in.file().c_str();
  auto line = in.line();
  auto text = in.text().c_str();
  interface::principia__LogWarning(file, line, text);
}

void MonitorSetName::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_i(in.i);
  m->set_name(in.name);
}

void MonitorSetName::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto i = in.i();
  auto name = in.name().c_str();
  interface::principia__MonitorSetName(i, name);
}

void MonitorStart::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_i(in.i);
}

void MonitorStart::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto i = in.i();
  interface::principia__MonitorStart(i);
}

void MonitorStop::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_i(in.i);
}

void MonitorStop::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto i = in.i();
  interface::principia__MonitorStop(i);
}

void NavballOrientation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_ship_world_position() = SerializeXYZ(in.ship_world_position);
}

void NavballOrientation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void NavballOrientation::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto ship_world_position = DeserializeXYZ(in.ship_world_position(), pointer_map);
  auto const result = interface::principia__NavballOrientation(plugin, sun_world_position, ship_world_position);
  PRINCIPIA_CHECK_EQ(DeserializeWXYZ(message.return_().result(), pointer_map), result);
}

void NewPlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_game_epoch(in.game_epoch);
  m->set_solar_system_epoch(in.solar_system_epoch);
  m->set_planetarium_rotation_in_degrees(in.planetarium_rotation_in_degrees);
}

void NewPlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewPlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto game_epoch = in.game_epoch().c_str();
  auto solar_system_epoch = in.solar_system_epoch().c_str();
  auto planetarium_rotation_in_degrees = in.planetarium_rotation_in_degrees();
  auto const result = interface::principia__NewPlugin(game_epoch, solar_system_epoch, planetarium_rotation_in_degrees);
  Insert(message.return_().result(), result, pointer_map);
}

void PartApplyIntrinsicForce::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_force_in_kilonewtons() = SerializeXYZ(in.force_in_kilonewtons);
}

void PartApplyIntrinsicForce::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto force_in_kilonewtons = DeserializeXYZ(in.force_in_kilonewtons(), pointer_map);
  interface::principia__PartApplyIntrinsicForce(plugin, part_id, force_in_kilonewtons);
}

void PartApplyIntrinsicForceAtPosition::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_force_in_kilonewtons() = SerializeXYZ(in.force_in_kilonewtons);
  *m->mutable_lever_arm() = SerializeXYZ(in.lever_arm);
}

void PartApplyIntrinsicForceAtPosition::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto force_in_kilonewtons = DeserializeXYZ(in.force_in_kilonewtons(), pointer_map);
  auto lever_arm = DeserializeXYZ(in.lever_arm(), pointer_map);
  interface::principia__PartApplyIntrinsicForceAtPosition(plugin, part_id, force_in_kilonewtons, lever_arm);
}

void PartApplyIntrinsicTorque::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_torque_in_kilonewton_metre() = SerializeXYZ(in.torque_in_kilonewton_metre);
}

void PartApplyIntrinsicTorque::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto torque_in_kilonewton_metre = DeserializeXYZ(in.torque_in_kilonewton_metre(), pointer_map);
  interface::principia__PartApplyIntrinsicTorque(plugin, part_id, torque_in_kilonewton_metre);
}

void PartGetActualRigidMotion::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_origin() = SerializeOrigin(in.origin);
}

void PartGetActualRigidMotion::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQPRW(result);
}

void PartGetActualRigidMotion::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto origin = DeserializeOrigin(in.origin(), pointer_map);
  auto const result = interface::principia__PartGetActualRigidMotion(plugin, part_id, origin);
  PRINCIPIA_CHECK_EQ(DeserializeQPRW(message.return_().result(), pointer_map), result);
}

void PartIsTruthful::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
}

void PartIsTruthful::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void PartIsTruthful::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto const result = interface::principia__PartIsTruthful(plugin, part_id);
  PRINCIPIA_CHECK_EQ(message.return_().result(), result);
}

void PartSetApparentRigidMotion::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
  *m->mutable_degrees_of_freedom() = SerializeQP(in.degrees_of_freedom);
  *m->mutable_rotation() = SerializeWXYZ(in.rotation);
  *m->mutable_angular_velocity() = SerializeXYZ(in.angular_velocity);
}

void PartSetApparentRigidMotion::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  auto degrees_of_freedom = DeserializeQP(in.degrees_of_freedom(), pointer_map);
  auto rotation = DeserializeWXYZ(in.rotation(), pointer_map);
  auto angular_velocity = DeserializeXYZ(in.angular_velocity(), pointer_map);
  interface::principia__PartSetApparentRigidMotion(plugin, part_id, degrees_of_freedom, rotation, angular_velocity);
}

void PlanetariumCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_xyz_opengl_camera_x_in_world() = SerializeXYZ(in.xyz_opengl_camera_x_in_world);
  *m->mutable_xyz_opengl_camera_y_in_world() = SerializeXYZ(in.xyz_opengl_camera_y_in_world);
  *m->mutable_xyz_opengl_camera_z_in_world() = SerializeXYZ(in.xyz_opengl_camera_z_in_world);
  *m->mutable_xyz_camera_position_in_world() = SerializeXYZ(in.xyz_camera_position_in_world);
  m->set_focal(in.focal);
  m->set_field_of_view(in.field_of_view);
  m->set_inverse_scale_factor(in.inverse_scale_factor);
  m->set_angular_resolution(in.angular_resolution);
  *m->mutable_scaled_space_origin() = SerializeXYZ(in.scaled_space_origin);
}

void PlanetariumCreate::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void PlanetariumCreate::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto xyz_opengl_camera_x_in_world = DeserializeXYZ(in.xyz_opengl_camera_x_in_world(), pointer_map);
  auto xyz_opengl_camera_y_in_world = DeserializeXYZ(in.xyz_opengl_camera_y_in_world(), pointer_map);
  auto xyz_opengl_camera_z_in_world = DeserializeXYZ(in.xyz_opengl_camera_z_in_world(), pointer_map);
  auto xyz_camera_position_in_world = DeserializeXYZ(in.xyz_camera_position_in_world(), pointer_map);
  auto focal = in.focal();
  auto field_of_view = in.field_of_view();
  auto inverse_scale_factor = in.inverse_scale_factor();
  auto angular_resolution = in.angular_resolution();
  auto scaled_space_origin = DeserializeXYZ(in.scaled_space_origin(), pointer_map);
  auto const result = interface::principia__PlanetariumCreate(plugin, sun_world_position, xyz_opengl_camera_x_in_world, xyz_opengl_camera_y_in_world, xyz_opengl_camera_z_in_world, xyz_camera_position_in_world, focal, field_of_view, inverse_scale_factor, angular_resolution, scaled_space_origin);
  Insert(message.return_().result(), result, pointer_map);
}

void PlanetariumDelete::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_planetarium(SerializePointer(*in.planetarium));
}

void PlanetariumDelete::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_planetarium(SerializePointer(*out.planetarium));
}

void PlanetariumDelete::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  [[maybe_unused]] auto const& out = message.out();
  interface::principia__PlanetariumDelete(&planetarium);
  Delete(in.planetarium(), pointer_map);
}

void PlanetariumPlotCelestialFutureTrajectory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_vessel_guid(in.vessel_guid);
  m->set_vertices(SerializePointer(in.vertices));
  m->set_vertices_size(in.vertices_size);
}

void PlanetariumPlotCelestialFutureTrajectory::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_minimal_distance_from_camera(*out.minimal_distance_from_camera);
  m->set_vertex_count(*out.vertex_count);
}

void PlanetariumPlotCelestialFutureTrajectory::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto vessel_guid = in.vessel_guid().c_str();
  std::vector<ScaledSpacePoint> vertices_storage;
  auto vertices = [&vertices_storage](std::int32_t const vertices_size){
    vertices_storage.resize(vertices_size);
    return vertices_storage.data();
  }(in.vertices_size());
  auto vertices_size = in.vertices_size();
  [[maybe_unused]] auto const& out = message.out();
  double minimal_distance_from_camera;
  int vertex_count;
  interface::principia__PlanetariumPlotCelestialFutureTrajectory(planetarium, plugin, celestial_index, vessel_guid, vertices, vertices_size, &minimal_distance_from_camera, &vertex_count);
}

void PlanetariumPlotCelestialPastTrajectory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_max_history_length(in.max_history_length);
  m->set_vertices(SerializePointer(in.vertices));
  m->set_vertices_size(in.vertices_size);
}

void PlanetariumPlotCelestialPastTrajectory::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_minimal_distance_from_camera(*out.minimal_distance_from_camera);
  m->set_vertex_count(*out.vertex_count);
}

void PlanetariumPlotCelestialPastTrajectory::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto max_history_length = in.max_history_length();
  std::vector<ScaledSpacePoint> vertices_storage;
  auto vertices = [&vertices_storage](std::int32_t const vertices_size){
    vertices_storage.resize(vertices_size);
    return vertices_storage.data();
  }(in.vertices_size());
  auto vertices_size = in.vertices_size();
  [[maybe_unused]] auto const& out = message.out();
  double minimal_distance_from_camera;
  int vertex_count;
  interface::principia__PlanetariumPlotCelestialPastTrajectory(planetarium, plugin, celestial_index, max_history_length, vertices, vertices_size, &minimal_distance_from_camera, &vertex_count);
}

void PlanetariumPlotEquipotential::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
  m->set_vertices(SerializePointer(in.vertices));
  m->set_vertices_size(in.vertices_size);
}

void PlanetariumPlotEquipotential::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_vertex_count(*out.vertex_count);
}

void PlanetariumPlotEquipotential::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto index = in.index();
  std::vector<ScaledSpacePoint> vertices_storage;
  auto vertices = [&vertices_storage](std::int32_t const vertices_size){
    vertices_storage.resize(vertices_size);
    return vertices_storage.data();
  }(in.vertices_size());
  auto vertices_size = in.vertices_size();
  [[maybe_unused]] auto const& out = message.out();
  int vertex_count;
  interface::principia__PlanetariumPlotEquipotential(planetarium, plugin, index, vertices, vertices_size, &vertex_count);
}

void PlanetariumPlotFlightPlanSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  m->set_vertices(SerializePointer(in.vertices));
  m->set_vertices_size(in.vertices_size);
}

void PlanetariumPlotFlightPlanSegment::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_vertex_count(*out.vertex_count);
}

void PlanetariumPlotFlightPlanSegment::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  std::vector<ScaledSpacePoint> vertices_storage;
  auto vertices = [&vertices_storage](std::int32_t const vertices_size){
    vertices_storage.resize(vertices_size);
    return vertices_storage.data();
  }(in.vertices_size());
  auto vertices_size = in.vertices_size();
  [[maybe_unused]] auto const& out = message.out();
  int vertex_count;
  interface::principia__PlanetariumPlotFlightPlanSegment(planetarium, plugin, vessel_guid, index, t_max, vertices, vertices_size, &vertex_count);
}

void PlanetariumPlotPrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  m->set_vertices(SerializePointer(in.vertices));
  m->set_vertices_size(in.vertices_size);
}

void PlanetariumPlotPrediction::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_vertex_count(*out.vertex_count);
}

void PlanetariumPlotPrediction::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  std::vector<ScaledSpacePoint> vertices_storage;
  auto vertices = [&vertices_storage](std::int32_t const vertices_size){
    vertices_storage.resize(vertices_size);
    return vertices_storage.data();
  }(in.vertices_size());
  auto vertices_size = in.vertices_size();
  [[maybe_unused]] auto const& out = message.out();
  int vertex_count;
  interface::principia__PlanetariumPlotPrediction(planetarium, plugin, vessel_guid, t_max, vertices, vertices_size, &vertex_count);
}

void PlanetariumPlotPsychohistory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_planetarium(SerializePointer(in.planetarium));
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_max_history_length(in.max_history_length);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  m->set_vertices(SerializePointer(in.vertices));
  m->set_vertices_size(in.vertices_size);
}

void PlanetariumPlotPsychohistory::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_vertex_count(*out.vertex_count);
}

void PlanetariumPlotPsychohistory::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto planetarium = DeserializePointer<Planetarium const*>(in.planetarium(), pointer_map);
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto max_history_length = in.max_history_length();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  std::vector<ScaledSpacePoint> vertices_storage;
  auto vertices = [&vertices_storage](std::int32_t const vertices_size){
    vertices_storage.resize(vertices_size);
    return vertices_storage.data();
  }(in.vertices_size());
  auto vertices_size = in.vertices_size();
  [[maybe_unused]] auto const& out = message.out();
  int vertex_count;
  interface::principia__PlanetariumPlotPsychohistory(planetarium, plugin, vessel_guid, max_history_length, t_max, vertices, vertices_size, &vertex_count);
}

void PrepareToReportCollisions::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void PrepareToReportCollisions::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  interface::principia__PrepareToReportCollisions(plugin);
}

void RenderedPredictionApsides::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  m->set_celestial_index(in.celestial_index);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void RenderedPredictionApsides::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_apoapsides(SerializePointer(*out.apoapsides));
  m->set_periapsides(SerializePointer(*out.periapsides));
}

void RenderedPredictionApsides::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  auto celestial_index = in.celestial_index();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* apoapsides;
  Iterator* periapsides;
  interface::principia__RenderedPredictionApsides(plugin, vessel_guid, t_max, celestial_index, sun_world_position, max_points, &apoapsides, &periapsides);
  Insert(out.apoapsides(), apoapsides, pointer_map);
  Insert(out.periapsides(), periapsides, pointer_map);
}

void RenderedPredictionClosestApproaches::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void RenderedPredictionClosestApproaches::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_closest_approaches(SerializePointer(*out.closest_approaches));
}

void RenderedPredictionClosestApproaches::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* closest_approaches;
  interface::principia__RenderedPredictionClosestApproaches(plugin, vessel_guid, sun_world_position, max_points, &closest_approaches);
  Insert(out.closest_approaches(), closest_approaches, pointer_map);
}

void RenderedPredictionNodes::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.t_max != nullptr) {
    m->set_t_max(*in.t_max);
  }
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_max_points(in.max_points);
}

void RenderedPredictionNodes::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_ascending(SerializePointer(*out.ascending));
  m->set_descending(SerializePointer(*out.descending));
}

void RenderedPredictionNodes::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  double t_max_storage;
  auto t_max = in.has_t_max() ? [&t_max_storage](double value) {
            t_max_storage = value;
            return &t_max_storage;
          }(in.t_max()) : nullptr;
  auto sun_world_position = DeserializeXYZ(in.sun_world_position(), pointer_map);
  auto max_points = in.max_points();
  [[maybe_unused]] auto const& out = message.out();
  Iterator* ascending;
  Iterator* descending;
  interface::principia__RenderedPredictionNodes(plugin, vessel_guid, t_max, sun_world_position, max_points, &ascending, &descending);
  Insert(out.ascending(), ascending, pointer_map);
  Insert(out.descending(), descending, pointer_map);
}

void ReportGroundCollision::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part_id(in.part_id);
}

void ReportGroundCollision::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto part_id = in.part_id();
  interface::principia__ReportGroundCollision(plugin, part_id);
}

void ReportPartCollision::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_part1_id(in.part1_id);
  m->set_part2_id(in.part2_id);
}

void ReportPartCollision::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto part1_id = in.part1_id();
  auto part2_id = in.part2_id();
  interface::principia__ReportPartCollision(plugin, part1_id, part2_id);
}

void SayHello::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void SayHello::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__SayHello();
  PRINCIPIA_CHECK_EQ(message.return_().result().c_str(), result);
}

void SayNotFound::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeStatus(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void SayNotFound::Run(Message const& message, Player::PointerMap& pointer_map) {
  auto const result = interface::principia__SayNotFound();
  InsertStatus(message.return_().result(), *result, pointer_map);
  PRINCIPIA_CHECK_EQ(DeserializeStatus(message.return_().result(), pointer_map), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void SerializePlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_serializer(SerializePointer(*in.serializer));
  m->set_compressor(in.compressor);
  m->set_encoder(in.encoder);
}

void SerializePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_serializer(SerializePointer(*out.serializer));
}

void SerializePlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void SerializePlugin::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto serializer = DeserializePointer<PullSerializer*>(in.serializer(), pointer_map);
  auto compressor = in.compressor().c_str();
  auto encoder = in.encoder().c_str();
  [[maybe_unused]] auto const& out = message.out();
  auto const result = interface::principia__SerializePlugin(plugin, &serializer, compressor, encoder);
  if (result == nullptr) {
    Delete(in.serializer(), pointer_map);
  }
  if (result != nullptr) {
    Insert(out.serializer(), serializer, pointer_map);
  }
  if (result != nullptr) {
    Insert(message.return_().result(), result, pointer_map);
  }
}

void SetBufferDuration::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_seconds(in.seconds);
}

void SetBufferDuration::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto seconds = in.seconds();
  interface::principia__SetBufferDuration(seconds);
}

void SetBufferedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_max_severity(in.max_severity);
}

void SetBufferedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto max_severity = in.max_severity();
  interface::principia__SetBufferedLogging(max_severity);
}

void SetFlag::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_name(in.name);
  m->set_value(in.value);
}

void SetFlag::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto name = in.name().c_str();
  auto value = in.value().c_str();
  interface::principia__SetFlag(name, value);
}

void SetMainBody::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void SetMainBody::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto index = in.index();
  interface::principia__SetMainBody(plugin, index);
}

void SetPlottingFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializePlottingFrameParameters(in.parameters);
}

void SetPlottingFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  std::vector<int const*> primary_index_storage;
  std::vector<int const*> secondary_index_storage;
  auto parameters = DeserializePlottingFrameParameters(in.parameters(), pointer_map, primary_index_storage, secondary_index_storage);
  interface::principia__SetPlottingFrame(plugin, parameters);
}

void SetStderrLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetStderrLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetStderrLogging(min_severity);
}

void SetSuppressedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetSuppressedLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetSuppressedLogging(min_severity);
}

void SetTargetVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_reference_body_index(in.reference_body_index);
}

void SetTargetVessel::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto reference_body_index = in.reference_body_index();
  interface::principia__SetTargetVessel(plugin, vessel_guid, reference_body_index);
}

void SetVerboseLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_level(in.level);
}

void SetVerboseLogging::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto level = in.level();
#if PRINCIPIA_SET_VERBOSE_LOGGING
  interface::principia__SetVerboseLogging(level);
#endif
}

void SetWorldRotationalReferenceFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_index(in.index);
}

void SetWorldRotationalReferenceFrame::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto index = in.index();
  interface::principia__SetWorldRotationalReferenceFrame(plugin, index);
}

void UnmanageableVesselVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_degrees_of_freedom() = SerializeQP(in.degrees_of_freedom);
  m->set_celestial_index(in.celestial_index);
}

void UnmanageableVesselVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void UnmanageableVesselVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto degrees_of_freedom = DeserializeQP(in.degrees_of_freedom(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__UnmanageableVesselVelocity(plugin, degrees_of_freedom, celestial_index);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void UpdateCelestialHierarchy::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_parent_index(in.parent_index);
}

void UpdateCelestialHierarchy::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto celestial_index = in.celestial_index();
  auto parent_index = in.parent_index();
  interface::principia__UpdateCelestialHierarchy(plugin, celestial_index, parent_index);
}

void UpdatePrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  for (char const* const* vessel_guids = in.vessel_guids; vessel_guids != nullptr && *vessel_guids != nullptr; ++vessel_guids) {
    *m->add_vessel_guids() = *vessel_guids;
  }
}

void UpdatePrediction::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  std::vector<char const*> vessel_guids_storage;
  auto vessel_guids = [&vessel_guids_storage](::google::protobuf::RepeatedPtrField<std::string> const& strings) {
            for (auto const& s : strings) {
              vessel_guids_storage.push_back(s.c_str());
            }
            vessel_guids_storage.push_back(nullptr);
            return &vessel_guids_storage[0];
          }(in.vessel_guids());
  interface::principia__UpdatePrediction(plugin, vessel_guids);
}

void VesselBinormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselBinormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselBinormal::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselBinormal(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void VesselFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_parent_index(in.parent_index);
  m->set_vessel_guid(in.vessel_guid);
}

void VesselFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void VesselFromParent::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto parent_index = in.parent_index();
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselFromParent(plugin, parent_index, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeQP(message.return_().result(), pointer_map), result);
}

void VesselGetAnalysis::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  if (in.revolutions_per_cycle != nullptr) {
    m->set_revolutions_per_cycle(*in.revolutions_per_cycle);
  }
  if (in.days_per_cycle != nullptr) {
    m->set_days_per_cycle(*in.days_per_cycle);
  }
  m->set_ground_track_revolution(in.ground_track_revolution);
}

void VesselGetAnalysis::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeOrbitAnalysis(*result);
  message->mutable_return_()->set_address(SerializePointer(result));
}

void VesselGetAnalysis::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  int revolutions_per_cycle_storage;
  auto revolutions_per_cycle = in.has_revolutions_per_cycle() ? [&revolutions_per_cycle_storage](int value) {
            revolutions_per_cycle_storage = value;
            return &revolutions_per_cycle_storage;
          }(in.revolutions_per_cycle()) : nullptr;
  int days_per_cycle_storage;
  auto days_per_cycle = in.has_days_per_cycle() ? [&days_per_cycle_storage](int value) {
            days_per_cycle_storage = value;
            return &days_per_cycle_storage;
          }(in.days_per_cycle()) : nullptr;
  auto ground_track_revolution = in.ground_track_revolution();
  auto const result = interface::principia__VesselGetAnalysis(plugin, vessel_guid, revolutions_per_cycle, days_per_cycle, ground_track_revolution);
  InsertOrbitAnalysis(message.return_().result(), *result, pointer_map);
  int primary_index_storage;
  OrbitalElements elements_storage;
  OrbitRecurrence recurrence_storage;
  EquatorialCrossings ground_track_equatorial_crossings_storage;
  SolarTimesOfNodes solar_times_of_nodes_storage;
  PRINCIPIA_CHECK_EQ(DeserializeOrbitAnalysis(message.return_().result(), pointer_map, primary_index_storage, elements_storage, recurrence_storage, ground_track_equatorial_crossings_storage, solar_times_of_nodes_storage), *result);
  Insert(message.return_().address(), result, pointer_map);
}

void VesselGetPredictionAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselGetPredictionAdaptiveStepParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(result);
}

void VesselGetPredictionAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselGetPredictionAdaptiveStepParameters(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeAdaptiveStepParameters(message.return_().adaptive_step_parameters(), pointer_map), result);
}

void VesselNormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselNormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselNormal::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselNormal(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void VesselRequestAnalysis::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_mission_duration(in.mission_duration);
}

void VesselRequestAnalysis::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto mission_duration = in.mission_duration();
  interface::principia__VesselRequestAnalysis(plugin, vessel_guid, mission_duration);
}

void VesselSetPredictionAdaptiveStepParameters::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_adaptive_step_parameters() = SerializeAdaptiveStepParameters(in.adaptive_step_parameters);
}

void VesselSetPredictionAdaptiveStepParameters::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto adaptive_step_parameters = DeserializeAdaptiveStepParameters(in.adaptive_step_parameters(), pointer_map);
  interface::principia__VesselSetPredictionAdaptiveStepParameters(plugin, vessel_guid, adaptive_step_parameters);
}

void VesselTangent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselTangent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselTangent::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselTangent(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

void VesselVelocity::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselVelocity::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselVelocity::Run(Message const& message, Player::PointerMap& pointer_map) {
  [[maybe_unused]] auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(in.plugin(), pointer_map);
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselVelocity(plugin, vessel_guid);
  PRINCIPIA_CHECK_EQ(DeserializeXYZ(message.return_().result(), pointer_map), result);
}

