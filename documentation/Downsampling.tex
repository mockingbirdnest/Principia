\documentclass[10pt, a4paper, twoside]{basestyle}

\usepackage{tikz}
\usetikzlibrary{cd}
\usetikzlibrary{patterns}

\usepackage[ruled,vlined]{algorithm2e}
\usepackage[Mathematics]{semtex}
\usepackage{chngcntr}
\counterwithout{equation}{section}

% Must come last.
\usepackage{siunitx}
\sisetup{math-micro=\text{µ},text-micro=µ}

%%%% Shorthands.
\DeclareMathOperator{\bias}{\mathit{bias}}
\DeclareMathOperator{\ULP}{\mathfrak u}
\DeclareMathOperator{\mant}{\mathfrak m}
\DeclareMathOperator{\expn}{\mathfrak e}
\DeclareMathOperator{\truncate}{\StandardSymbol{Tr}}
\DeclareMathOperator{\twosum}{\StandardSymbol{TwoSum}}
\DeclareMathOperator{\quicktwosum}{\StandardSymbol{QuickTwoSum}}
\DeclareMathOperator{\dwplusfp}{\StandardSymbol{DWPlusFP}}
\DeclareMathOperator{\twodifference}{\StandardSymbol{TwoDifference}}
\DeclareMathOperator{\quicktwodifference}{\StandardSymbol{QuickTwoDifference}}
\DeclareMathOperator{\cmod}{\StandardSymbol{cmod}}

% Rounding brackets will be heavily nested, and reading the nesting depth is critically important,
% so we make them grow for readability.
\newcommand{\round}[1]{\doubleSquareBrackets*{#1}}
\newcommand{\roundTowardZero}[1]{\doubleSquareBrackets{#1}_0}
\newcommand{\roundTowardPositive}[1]{\doubleSquareBrackets{#1}_+}
\newcommand{\roundTowardNegative}[1]{\doubleSquareBrackets{#1}_-}
\newcommand{\roundAll}[1]{\doubleSquareBrackets{#1}_⋯}
\newcommand{\hex}[1]{{_{16}}\mathrm{#1}}
\newcommand{\bin}[1]{{_{2}}\mathrm{#1}}
\newcommand{\red}[1]{\tilde{#1}}

%%%% Title and authors.

\title{Downsampling Discrete Trajectories}
\date{\printdate{2026-01-26}}
\author{Pascal~Leroy (phl)}
\begin{document}
\maketitle
\begin{sloppypar}
\noindent
This document describes the computations that are performed by the method \texttt{Append} of class \texttt{DiscreteTrajectorySegment} to downsample the points produced by an integrator and produce a compact yet accurate representation of discrete trajectories.
\end{sloppypar}

\section*{Overview}

An integrator produces a stream of tuples $\tuple{t_i, q_i, p_i}$ giving the degrees of freedom of a massless body at discrete times $t_i$.  The purpose of downsampling is twofold:
\begin{itemize}[nosep]
\item Construct cubic Hermite splines that interpolate between consecutive $t_i$ to make it possible to evaluate the degrees of freedom at any time with sufficient accuracy.
\item Make the representation more compact by dropping the tuples $\tuple{t_i, q_i, p_i}$ for $i \in \intopen{1}{n}$ if the Hermite spline constructed based on $\tuple{t_1, q_1, p_1}$ and $\tuple{t_n, q_n, p_n}$ approximates these tuples with sufficient accuracy.
\end{itemize}

\section*{A Brute Force Algorithm}

The best way to describe the problem we want to solve is to present a brute-force algorithm that provides an exact solution:

\begin{algorithm}
\DontPrintSemicolon
\SetAlgoLined
\LinesNumbered
\SetNlSty{texttt}{}{.}
\SetAlgoNlRelativeSize{0}
\KwIn{A tolerance $\gh$ and a stream of tuples $\tuple{t_i, q_i, p_i}$.}
\KwOut{A stream of intervals $\intclos{j_1}{j_2}$ such that the Hermite spline based on the tuples $\tuple{t_{j_1}, q_{j_1}, p_{j_1}}$ and $\tuple{t_{j_2}, q_{j_2}, p_{j_2}}$ approximates the input tuples $\tuple{t_i, q_i, p_i}$ for $i \in \intclos{j_1}{j_2}$ with a tolerance better that $\gh$.}
\SetKwFunction{BruteForceDownsampling}{BruteForceDownsampling}
Let $j \leftarrow 1$.\;
\While{not at end of input stream} {
  Compute the Hermite spline $h$ based on the tuples $\tuple{t_{j}, q_{j}, p_{j}}$ and $\tuple{t_i, q_i, p_i}$.\;
  \uIf{$\summationSign_{k = j}^i \Lnorm[2]{h\of{t_k} - q_k} > \gh$} {
    Emit the interval $\intclos{j}{i - 1}$.\;
    Let $j \leftarrow i - 1$.
  }
}
Emit the interval $\intclos{j}{n}$ where $n$ is the index of the last element in the stream.\;
\caption{BruteForceDownsampling.}
\end{algorithm}

A few things are worth noting here:
\begin{itemize}[nosep]
\item Only the tuples $\tuple{t_{j_1}, q_{j_1}, p_{j_1}}$ and $\tuple{t_{j_2}, q_{j_2}, p_{j_2}}$ corresponding to the bounds of the intervals $\intclos{j_1}{j_2}$ need to be stored permanently.  The other tuples can be interpolated with an accuracy better than $\gh$.
\item The Hermite splines do not need to be stored permanently; they can be reconstructed based on the tuples $\tuple{t_{j_1}, q_{j_1}, p_{j_1}}$ and $\tuple{t_{j_2}, q_{j_2}, p_{j_2}}$.
\item The algorithm is optimal in the sense that it produces the longest possible intervals $\intclos{j_1}{j_2}$ that satisfy the tolerance $\gh$.
\item For each input tuple, the algorithm needs to scan all past tuples since the upper bound $j$ of the last emitted interval.  Therefore, the algorithm is quadratic in the number of tuples in the input stream.
\end{itemize}

\section*{A Binary Search Algorithm}

In order to avoid the quadratic complexity, we used to use a binary search algorithm as follows:

\begin{algorithm}
\DontPrintSemicolon
\SetAlgoLined
\LinesNumbered
\SetNlSty{texttt}{}{.}
\SetAlgoNlRelativeSize{0}
\SetKwFunction{SearchInterval}{SearchInterval}
\KwIn{A tolerance $\gh$, an integer $N$, and a stream of tuples $\tuple{t_i, q_i, p_i}$.}
\KwOut{A stream of intervals $\intclos{j_1}{j_2}$ such that the Hermite spline based on the tuples $\tuple{t_{j_1}, q_{j_1}, p_{j_1}}$ and $\tuple{t_{j_2}, q_{j_2}, p_{j_2}}$ approximates the input tuples $\tuple{t_i, q_i, p_i}$ for $i \in \intclos{j_1}{j_2}$ with a tolerance better that $\gh$.}
\SetKwData{A}{A}
\SetKwFunction{BinarySearchDownsampling}{BinarySearchDownsampling}
\SetKwProg{Fn}{Function}{ is}{end}
Let $A$ be an array of size $N$ used to store tuples.\;
\While{not at end of input stream} {
  \uIf{\A is full}{
    Let $k \leftarrow \Floor{N/2}$.\;
    Emit \SearchInterval{\A, $1$, $k$}.\;
    Emit \SearchInterval{\A, $k + 1$, $N$}.\;
    Clear \A.
  }
  Append $\tuple{t_i, q_i, p_i}$ to \A.\;
}
\BlankLine
\Fn{\SearchInterval{A, $i_1$, $i_2$}} {
  Compute the Hermite spline $h$ based on the tuples $\tuple{t_{i_1}, q_{i_1}, p_{i_1}}$ and $\tuple{t_{i_2}, q_{i_2}, p_{i_2}}$.\;
  \uIf{$\summationSign_{k = {i_1}}^{i_2} \Lnorm[2]{h\of{t_k} - q_k} > \gh$} {
    Let $k \leftarrow \Floor{i_2/2}$.\;
    Emit \SearchInterval{\A, $i_1$, $k$}.\;
    Emit \SearchInterval{\A, $k + 1$, $i_2$}.
  }
  \Else {
    Emit $\intclos{i_1}{i_2}$.
  }
}
\caption{BinarySearchDownsampling.}
\end{algorithm}

This algorithm has the following properties:
\begin{itemize}[nosep]
\item The array $A$ must be stored permanently since it contains tuples that have not been downsampled yet and that will be needed to make a future decision about the intervals to emit.
\item The choice of $N$ involves a trade-off: $N$ must be large enough that the downsampling is effective and produces long intervals $\intclos{j_1}{j_2}$; but it must not be so large that the size of $A$ affects performance.
\item The algorithm has a complexity of $\BigO\of{N \log N}$ on average and $\BigO\of{N^2}$ in the worst case.
\item The algorithm does not produce the longest possible intervals: in the worst case, all the emitted intervals may be too small by a factor of 2.
\end{itemize}

\end{document}