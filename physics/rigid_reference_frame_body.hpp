#pragma once

#include "physics/rigid_reference_frame.hpp"

#include <memory>
#include <utility>

#include "geometry/r3x3_matrix.hpp"
#include "numerics/elementary_functions.hpp"
#include "physics/barycentric_rotating_reference_frame.hpp"
#include "physics/body_centred_body_direction_reference_frame.hpp"
#include "physics/body_centred_non_rotating_reference_frame.hpp"
#include "physics/body_surface_reference_frame.hpp"
#include "quantities/si.hpp"

namespace principia {
namespace physics {
namespace _rigid_reference_frame {
namespace internal {

using namespace principia::geometry::_r3x3_matrix;
using namespace principia::numerics::_elementary_functions;
using namespace principia::physics::_barycentric_rotating_reference_frame;
using namespace principia::physics::_body_centred_body_direction_reference_frame;  // NOLINT
using namespace principia::physics::_body_centred_non_rotating_reference_frame;
using namespace principia::physics::_body_surface_reference_frame;
using namespace principia::quantities::_si;

template<typename InertialFrame, typename ThisFrame>
SimilarMotion<InertialFrame, ThisFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::ToThisFrameAtTimeSimilarly(
    Instant const& t) const {
  return ToThisFrameAtTime(t).template Forget<SimilarMotion>();
}

template<typename InertialFrame, typename ThisFrame>
SimilarMotion<ThisFrame, InertialFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::FromThisFrameAtTimeSimilarly(
    Instant const& t) const {
  return FromThisFrameAtTime(t).template Forget<SimilarMotion>();
}

template<typename InertialFrame, typename ThisFrame>
RigidMotion<InertialFrame, ThisFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::ToThisFrameAtTime(
    Instant const& t) const {
  return FromThisFrameAtTime(t).Inverse();
}

template<typename InertialFrame, typename ThisFrame>
RigidMotion<ThisFrame, InertialFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::FromThisFrameAtTime(
    Instant const& t) const {
  return ToThisFrameAtTime(t).Inverse();
}

template<typename InertialFrame, typename ThisFrame>
Vector<Acceleration, ThisFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::GeometricAcceleration(
    Instant const& t,
    DegreesOfFreedom<ThisFrame> const& degrees_of_freedom) const {
  Vector<Acceleration, ThisFrame> gravitational_acceleration;
  Vector<Acceleration, ThisFrame> linear_acceleration;
  Vector<Acceleration, ThisFrame> coriolis_acceleration;
  Vector<Acceleration, ThisFrame> centrifugal_acceleration;
  Vector<Acceleration, ThisFrame> euler_acceleration;
  ComputeGeometricAccelerations(t,
                                degrees_of_freedom,
                                gravitational_acceleration,
                                linear_acceleration,
                                coriolis_acceleration,
                                centrifugal_acceleration,
                                euler_acceleration);

  return gravitational_acceleration +
         (linear_acceleration + coriolis_acceleration +
          centrifugal_acceleration + euler_acceleration);
}

template<typename InertialFrame, typename ThisFrame>
Vector<Acceleration, ThisFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::
RotationFreeGeometricAccelerationAtRest(
    Instant const& t,
    Position<ThisFrame> const& position) const {
  Vector<Acceleration, ThisFrame> gravitational_acceleration;
  Vector<Acceleration, ThisFrame> linear_acceleration;
  Vector<Acceleration, ThisFrame> coriolis_acceleration;
  Vector<Acceleration, ThisFrame> centrifugal_acceleration;
  Vector<Acceleration, ThisFrame> euler_acceleration;
  ComputeGeometricAccelerations(t,
                                {position, ThisFrame::unmoving},
                                gravitational_acceleration,
                                linear_acceleration,
                                coriolis_acceleration,
                                centrifugal_acceleration,
                                euler_acceleration);

  DCHECK_EQ(coriolis_acceleration, (Vector<Acceleration, ThisFrame>{}));
  return gravitational_acceleration +
         (linear_acceleration + centrifugal_acceleration);
}

template<typename InertialFrame, typename ThisFrame>
SpecificEnergy
RigidReferenceFrame<InertialFrame, ThisFrame>::GeometricPotential(
    Instant const& t,
    Position<ThisFrame> const& position) const {
  AcceleratedRigidMotion<InertialFrame, ThisFrame> const motion =
      MotionOfThisFrame(t);
  RigidMotion<InertialFrame, ThisFrame> const& to_this_frame =
      motion.rigid_motion();
  RigidMotion<ThisFrame, InertialFrame> const from_this_frame =
      to_this_frame.Inverse();

  AngularVelocity<ThisFrame> const Œ© = to_this_frame.orthogonal_map()(
      to_this_frame.template angular_velocity_of<ThisFrame>());
  Displacement<ThisFrame> const r = position - ThisFrame::origin;

  SpecificEnergy const gravitational_potential =
      GravitationalPotential(t,
                             from_this_frame.rigid_transformation()(position));
  SpecificEnergy const linear_potential = InnerProduct(
      r,
      to_this_frame.orthogonal_map()(
          motion.template acceleration_of_origin_of<ThisFrame>()));
  SpecificEnergy const centrifugal_potential = -0.5 * (Œ© * r / Radian).Norm¬≤();

  return gravitational_potential + (linear_potential + centrifugal_potential);
}

template<typename InertialFrame, typename ThisFrame>
not_null<std::unique_ptr<RigidReferenceFrame<InertialFrame, ThisFrame>>>
RigidReferenceFrame<InertialFrame, ThisFrame>::ReadFromMessage(
    serialization::ReferenceFrame const& message,
    not_null<Ephemeris<InertialFrame> const*> const ephemeris) {
  std::unique_ptr<RigidReferenceFrame> result;
  int extensions_found = 0;
  // NOTE(egg): the `static_cast`ing below is needed on MSVC, because the silly
  // compiler doesn't see the
  // `operator std::unique_ptr<RigidReferenceFrame>() &&`.
  if (message.HasExtension(
          serialization::BarycentricRotatingReferenceFrame::extension)) {
    ++extensions_found;
    result = static_cast<not_null<std::unique_ptr<RigidReferenceFrame>>>(
        BarycentricRotatingReferenceFrame<InertialFrame, ThisFrame>::
            ReadFromMessage(
                ephemeris,
                message.GetExtension(
                    serialization::BarycentricRotatingReferenceFrame::
                        extension)));
  }
  if (message.HasExtension(
          serialization::BodyCentredBodyDirectionReferenceFrame::extension)) {
    ++extensions_found;
    result = static_cast<not_null<std::unique_ptr<RigidReferenceFrame>>>(
        BodyCentredBodyDirectionReferenceFrame<InertialFrame, ThisFrame>::
            ReadFromMessage(
                ephemeris,
                message.GetExtension(
                    serialization::BodyCentredBodyDirectionReferenceFrame::
                        extension)));
  }
  if (message.HasExtension(
          serialization::BodyCentredNonRotatingReferenceFrame::extension)) {
    ++extensions_found;
    result = static_cast<not_null<std::unique_ptr<RigidReferenceFrame>>>(
        BodyCentredNonRotatingReferenceFrame<InertialFrame, ThisFrame>::
            ReadFromMessage(
                ephemeris,
                message.GetExtension(
                    serialization::BodyCentredNonRotatingReferenceFrame::
                        extension)));
  }
  if (message.HasExtension(
          serialization::BodySurfaceReferenceFrame::extension)) {
    ++extensions_found;
    result = static_cast<not_null<std::unique_ptr<RigidReferenceFrame>>>(
        BodySurfaceReferenceFrame<InertialFrame, ThisFrame>::
            ReadFromMessage(
                ephemeris,
                message.GetExtension(
                    serialization::BodySurfaceReferenceFrame::extension)));
  }
  CHECK_EQ(extensions_found, 1) << message.DebugString();
  return std::move(result);
}

template<typename InertialFrame, typename ThisFrame>
void RigidReferenceFrame<InertialFrame, ThisFrame>::
ComputeAngularDegreesOfFreedom(
    DegreesOfFreedom<InertialFrame> const& primary_degrees_of_freedom,
    DegreesOfFreedom<InertialFrame> const& secondary_degrees_of_freedom,
    Vector<Acceleration, InertialFrame> const& primary_acceleration,
    Vector<Acceleration, InertialFrame> const& secondary_acceleration,
    Rotation<InertialFrame, ThisFrame>& rotation,
    AngularVelocity<InertialFrame>& angular_velocity) {
  RelativeDegreesOfFreedom<InertialFrame> const reference =
       secondary_degrees_of_freedom - primary_degrees_of_freedom;

  Displacement<InertialFrame> const& r = reference.displacement();
  Velocity<InertialFrame> const ·πô = reference.velocity();
  Vector<Acceleration, InertialFrame> const rÃà =
      secondary_acceleration - primary_acceleration;

  Trihedron<Length, ArealSpeed> orthogonal;
  Trihedron<double, double> orthonormal;
  Trihedron<Length, ArealSpeed, 1> ùõõorthogonal;
  Trihedron<double, double, 1> ùõõorthonormal;

  ComputeTrihedra(r, ·πô, orthogonal, orthonormal);
  ComputeTrihedraDerivatives(
      r, ·πô, rÃà, orthogonal, orthonormal, ùõõorthogonal, ùõõorthonormal);
  rotation = ComputeRotation(orthonormal);
  angular_velocity = ComputeAngularVelocity(orthonormal, ùõõorthonormal);
}

template<typename InertialFrame, typename ThisFrame>
void RigidReferenceFrame<InertialFrame, ThisFrame>::ComputeTrihedra(
    Displacement<InertialFrame> const& r,
    Velocity<InertialFrame> const& ·πô,
    Trihedron<Length, ArealSpeed>& orthogonal,
    Trihedron<double, double>& orthonormal) {
  // Our orthogonal (but not orthonormal) trihedron for `ThisFrame`.
  Displacement<InertialFrame> const& F = r;
  Bivector<ArealSpeed, InertialFrame> const B = Wedge(r, ·πô);
  Vector<Product<Length, ArealSpeed>, InertialFrame> const N = B * F;

  // Our orthonormal trihedron.
  Vector<double, InertialFrame> const f = Normalize(F);
  Vector<double, InertialFrame> const n = Normalize(N);
  Bivector<double, InertialFrame> const b = Normalize(B);

  orthogonal = {.fore = F, .normal = N, .binormal = B};
  orthonormal = {.fore = f, .normal = n, .binormal = b};
}

template<typename InertialFrame, typename ThisFrame>
void RigidReferenceFrame<InertialFrame, ThisFrame>::ComputeTrihedraDerivatives(
    Displacement<InertialFrame> const& r,
    Velocity<InertialFrame> const& ·πô,
    Vector<Acceleration, InertialFrame> const& rÃà,
    Trihedron<Length, ArealSpeed> const& orthogonal,
    Trihedron<double, double> const& orthonormal,
    Trihedron<Length, ArealSpeed, 1>& ùõõorthogonal,
    Trihedron<double, double, 1>& ùõõorthonormal) {
  auto const& F = orthogonal.fore;
  auto const& N = orthogonal.normal;
  auto const& B = orthogonal.binormal;

  // The derivatives of the `orthogonal` trihedron.
  Velocity<InertialFrame> const& ·∏û = ·πô;
  Bivector<Variation<ArealSpeed>, InertialFrame> const ·∏Ç = Wedge(r, rÃà);
  Vector<Variation<Product<Length, ArealSpeed>>, InertialFrame> const ·πÑ =
      ·∏Ç * F + B * ·∏û;

  // For any multivector v this returns the derivative of v / ‚Äñv‚Äñ.
  auto ùõõnormalized = []<typename V>(V const& v, Variation<V> const& vÃá) {
    return (v.Norm¬≤() * vÃá - InnerProduct(v, vÃá) * v) / Pow<3>(v.Norm());
  };

  // The derivatives of the `orthonormal` trihedron.
  Vector<Variation<double>, InertialFrame> const ·∏ü = ùõõnormalized(F, ·∏û);
  Vector<Variation<double>, InertialFrame> const ·πÖ = ùõõnormalized(N, ·πÑ);
  Bivector<Variation<double>, InertialFrame> const ·∏É = ùõõnormalized(B, ·∏Ç);

  ùõõorthogonal = {.fore = ·∏û, .normal = ·πÑ, .binormal = ·∏Ç};
  ùõõorthonormal = {.fore = ·∏ü, .normal = ·πÖ, .binormal = ·∏É};
}

template<typename InertialFrame, typename ThisFrame>
void RigidReferenceFrame<InertialFrame, ThisFrame>::ComputeTrihedraDerivatives2(
    Displacement<InertialFrame> const& r,
    Velocity<InertialFrame> const& ·πô,
    Vector<Acceleration, InertialFrame> const& rÃà,
    Vector<Jerk, InertialFrame> const& r‚ÅΩ¬≥‚Åæ,
    Trihedron<Length, ArealSpeed> const& orthogonal,
    Trihedron<double, double> const& orthonormal,
    Trihedron<Length, ArealSpeed, 1> const& ùõõorthogonal,
    Trihedron<double, double, 1> const& ùõõorthonormal,
    Trihedron<Length, ArealSpeed, 2>& ùõõ¬≤orthogonal,
    Trihedron<double, double, 2>& ùõõ¬≤orthonormal) {
  auto const& F = orthogonal.fore;
  auto const& N = orthogonal.normal;
  auto const& B = orthogonal.binormal;
  auto const& ·∏û = ùõõorthogonal.fore;
  auto const& ·πÑ = ùõõorthogonal.normal;
  auto const& ·∏Ç = ùõõorthogonal.binormal;

  // The second derivatives of the `orthogonal` trihedron.
  Vector<Acceleration, InertialFrame> const& FÃà = rÃà;
  Bivector<Variation<ArealSpeed, 2>, InertialFrame> const BÃà =
      Wedge(·πô, rÃà) + Wedge(r, r‚ÅΩ¬≥‚Åæ);
  Vector<Variation<Product<Length, ArealSpeed>, 2>, InertialFrame> const NÃà =
      BÃà * F + 2 * ·∏Ç * ·∏û + B * FÃà;

  // For any multivector v this returns the second derivative of v / ‚Äñv‚Äñ.
  auto ùõõ¬≤normalized = []<typename V>(V const& v,
                                     Variation<V> const& vÃá,
                                     Variation<V, 2> const& vÃà) {
    return vÃà / v.Norm() -
           (2 * InnerProduct(v, vÃá) * vÃá + (vÃá.Norm¬≤() - InnerProduct(v, vÃà)) * v) /
               Pow<3>(v.Norm()) +
           3 * v * Pow<2>(InnerProduct(v, vÃá)) / Pow<5>(v.Norm());
  };

  // The second derivatives of the `orthonormal` trihedron.
  Vector<Variation<double, 2>, InertialFrame> const fÃà = ùõõ¬≤normalized(F, ·∏û, FÃà);
  Vector<Variation<double, 2>, InertialFrame> const nÃà = ùõõ¬≤normalized(N, ·πÑ, NÃà);
  Bivector<Variation<double, 2>, InertialFrame> const bÃà = ùõõ¬≤normalized(B, ·∏Ç, BÃà);

  ùõõ¬≤orthogonal = {.fore = FÃà, .normal = NÃà, .binormal = BÃà};
  ùõõ¬≤orthonormal = {.fore = fÃà, .normal = nÃà, .binormal = bÃà};
}

template<typename InertialFrame, typename ThisFrame>
Rotation<InertialFrame, ThisFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::ComputeRotation(
    Trihedron<double, double> const& orthonormal) {
  return Rotation<InertialFrame, ThisFrame>(orthonormal.fore,
                                            orthonormal.normal,
                                            orthonormal.binormal);
}

template<typename InertialFrame, typename ThisFrame>
AngularVelocity<InertialFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::ComputeAngularVelocity(
    Trihedron<double, double> const& orthonormal,
    Trihedron<double, double, 1> const& ùõõorthonormal) {
  auto const& f = orthonormal.fore;
  auto const& n = orthonormal.normal;
  auto const& b = orthonormal.binormal;
  auto const& ·∏ü = ùõõorthonormal.fore;
  auto const& ·πÖ = ùõõorthonormal.normal;
  auto const& ·∏É = ùõõorthonormal.binormal;

  return Radian * (Wedge(·πÖ, b) * f + Wedge(·∏É, f) * n + InnerProduct(·∏ü, n) * b);
}

template<typename InertialFrame, typename ThisFrame>
Bivector<AngularAcceleration, InertialFrame>
RigidReferenceFrame<InertialFrame, ThisFrame>::ComputeAngularAcceleration(
    Trihedron<double, double> const& orthonormal,
    Trihedron<double, double, 1> const& ùõõorthonormal,
    Trihedron<double, double, 2> const& ùõõ¬≤orthonormal) {
  auto const& f = orthonormal.fore;
  auto const& n = orthonormal.normal;
  auto const& b = orthonormal.binormal;
  auto const& ·∏ü = ùõõorthonormal.fore;
  auto const& ·πÖ = ùõõorthonormal.normal;
  auto const& ·∏É = ùõõorthonormal.binormal;
  auto const& fÃà = ùõõ¬≤orthonormal.fore;
  auto const& nÃà = ùõõ¬≤orthonormal.normal;
  auto const& bÃà = ùõõ¬≤orthonormal.binormal;

  return Radian * (
      (Wedge(nÃà, b) + Wedge(·πÖ, ·∏É)) * f + Wedge(·πÖ, b) * ·∏ü +
      (Wedge(bÃà, f) + Wedge(·∏É, ·∏ü)) * n + Wedge(·∏É, f) * ·πÖ +
      (InnerProduct(fÃà, n) + InnerProduct(·∏ü, ·πÖ)) * b + InnerProduct(·∏ü, n) * ·∏É);
}

template<typename InertialFrame, typename ThisFrame>
void RigidReferenceFrame<InertialFrame, ThisFrame>::
ComputeGeometricAccelerations(
    Instant const& t,
    DegreesOfFreedom<ThisFrame> const& degrees_of_freedom,
    Vector<Acceleration, ThisFrame>& gravitational_acceleration,
    Vector<Acceleration, ThisFrame>& linear_acceleration,
    Vector<Acceleration, ThisFrame>& coriolis_acceleration,
    Vector<Acceleration, ThisFrame>& centrifugal_acceleration,
    Vector<Acceleration, ThisFrame>& euler_acceleration) const {
  AcceleratedRigidMotion<InertialFrame, ThisFrame> const motion =
      MotionOfThisFrame(t);
  RigidMotion<InertialFrame, ThisFrame> const& to_this_frame =
      motion.rigid_motion();
  RigidMotion<ThisFrame, InertialFrame> const from_this_frame =
      to_this_frame.Inverse();

  // Beware, we want the angular velocity of ThisFrame as seen in the
  // InertialFrame, but pushed to ThisFrame.  Otherwise the sign is wrong.
  AngularVelocity<ThisFrame> const Œ© = to_this_frame.orthogonal_map()(
      to_this_frame.template angular_velocity_of<ThisFrame>());
  Variation<AngularVelocity<ThisFrame>> const dŒ©_over_dt =
      to_this_frame.orthogonal_map()(
          motion.template angular_acceleration_of<ThisFrame>());
  Displacement<ThisFrame> const r =
      degrees_of_freedom.position() - ThisFrame::origin;

  gravitational_acceleration = to_this_frame.orthogonal_map()(
      GravitationalAcceleration(t,
                                from_this_frame.rigid_transformation()(
                                    degrees_of_freedom.position())));
  linear_acceleration = -to_this_frame.orthogonal_map()(
      motion.template acceleration_of_origin_of<ThisFrame>());
  coriolis_acceleration = -2 * Œ© * degrees_of_freedom.velocity() / Radian;
  centrifugal_acceleration = -Œ© * (Œ© * r) / Pow<2>(Radian);
  euler_acceleration = -dŒ©_over_dt * r / Radian;
}

}  // namespace internal
}  // namespace _rigid_reference_frame
}  // namespace physics
}  // namespace principia
