#include "numerics/sin_cos.hpp"

#include <pmmintrin.h>

#include <limits>
#include <utility>

#include "base/tags.hpp"
#include "core-math/cos.h"
#include "core-math/sin.h"
#include "numerics/accurate_tables.mathematica.h"
#include "numerics/double_precision.hpp"
#include "numerics/elementary_functions.hpp"
#include "numerics/osaca.hpp"  // üßô For OSACA_*.
#include "numerics/polynomial_evaluators.hpp"
#include "numerics/m128d.hpp"

// The algorithms in this file are documented in `Sin Cos.pdf`.  To the extent
// possible, the code follows the notation of that document.
namespace principia {
namespace numerics {
namespace _sin_cos {
namespace internal {

using namespace principia::base::_tags;
using namespace principia::numerics::_accurate_tables;
using namespace principia::numerics::_double_precision;
using namespace principia::numerics::_elementary_functions;
using namespace principia::numerics::_polynomial_evaluators;
using namespace principia::numerics::_m128d;

#define OSACA_ANALYSED_FUNCTION Cos
#define OSACA_ANALYSED_FUNCTION_NAMESPACE
#if PRINCIPIA_COMPILER_MSVC
#define OSACA_ANALYSED_FUNCTION_TEMPLATE_PARAMETERS <FMAPresence::Present>
#else
#define OSACA_ANALYSED_FUNCTION_TEMPLATE_PARAMETERS <FMAPresence::Absent>
#endif
#define UNDER_OSACA_HYPOTHESES(expression)                                   \
  [&] {                                                                      \
    constexpr bool CanUseHardwareFMA = true;                                 \
    constexpr double x = 3;                                                  \
    /* From argument reduction. */                                           \
    constexpr double abs_x = x > 0 ? x : -x;                                 \
    constexpr std::int64_t n = static_cast<std::int64_t>(x * (2 / œÄ) + 0.5); \
    constexpr double reduction_value = x - n * C‚ÇÅ;                           \
    constexpr double reduction_error = n * Œ¥C‚ÇÅ;                              \
    /* Used to determine whether a better argument reduction is needed. */   \
    constexpr DoublePrecision<double> x_reduced =                            \
        TwoDifference(reduction_value, reduction_error);                     \
    constexpr double abs_x_reduced_value =                                   \
        x_reduced.value > 0 ? x_reduced.value : -x_reduced.value;            \
    /* Used in Sin to detect the near-0 case. */                             \
    constexpr double abs_xÃÉ =                                                 \
        x_reduced.value > 0 ? x_reduced.value : -x_reduced.value;            \
    /* Used throughout the top-level functions. */                           \
    constexpr std::int64_t quadrant = n & 0b11;                              \
    /* Not NaN is the only part that matters; used at the end of the    */   \
    /* top-level functions to determine whether to call the slow path.  */   \
    constexpr double value = 1;                                              \
    constexpr double muller_test_expression = value;                         \
    constexpr SC<double> values = {.sin = 0, .cos = 1};                      \
    return expression;                                                       \
  }()

using Argument = M128D;
using Value = M128D;

constexpr std::int64_t table_spacing_bits = 9;
constexpr double table_spacing_reciprocal = 1 << table_spacing_bits;
constexpr double table_spacing = 1.0 / table_spacing_reciprocal;
constexpr double sin_near_zero_cutoff = table_spacing / 2.0;

constexpr std::int64_t Œ∫‚ÇÅ = 8;
constexpr std::int64_t Œ∫ π‚ÇÅ = 5;
constexpr std::int64_t Œ∫‚ÇÇ = 18;
constexpr std::int64_t Œ∫ π‚ÇÇ = 14;
constexpr std::int64_t Œ∫ ∫‚ÇÇ = 15;
constexpr std::int64_t Œ∫‚ÇÉ = 18;

// These constants must be `constexpr` (and therefore `double`) to be used in
// the `OSACA_` macros.
constexpr double two_term_x_threshold = œÄ / 2 * (1LL << Œ∫‚ÇÅ);
constexpr double three_term_x_threshold = œÄ / 2 * (1LL << Œ∫‚ÇÇ);
constexpr double C‚ÇÅ = 0x1.921F'B544'42D0'0p0;
constexpr double Œ¥C‚ÇÅ = 0x1.8469'898C'C517'0p-48;
constexpr double C‚ÇÇ = 0x1.921F'B544'4000'0p0;
constexpr double C π‚ÇÇ = 0x1.68C2'34C4'C000'0p-39;
constexpr double Œ¥C‚ÇÇ = 0x1.98A2'E037'0734'5p-77;
constexpr double two_term_x_reduced_threshold =
    1.0 / (1LL << (-(Œ∫‚ÇÅ + Œ∫ π‚ÇÅ + Œ∫‚ÇÉ - std::numeric_limits<double>::digits + 2)));
constexpr double three_term_x_reduced_threshold =
    (1.0 / (1LL << (-(Œ∫‚ÇÉ - std::numeric_limits<double>::digits)))) *
    ((1LL << (-(Œ∫‚ÇÇ + Œ∫ π‚ÇÇ + Œ∫ ∫‚ÇÇ - std::numeric_limits<double>::digits + 2))) +
     4);

constexpr double sin_near_zero_e = 0x1.0000'B2D8'01D8'0p0;  // 2^-70.517.
constexpr double sin_e = 0x1.0002'6ABE'272D'9p0;  // 2^-68.726.
constexpr double cos_e = 0x1.0001'B839'335E'1p0;  // 2^-69.217.

SlowPathCallback slow_path_sin_callback = nullptr;
SlowPathCallback slow_path_cos_callback = nullptr;

// Forward declarations needed by the OSACA macros.
template<FMAPresence fma_presence>
double __cdecl Sin(double x);
template<FMAPresence fma_presence>
double __cdecl Cos(double x);

namespace m128d {

M128D const quiet_NaN(std::numeric_limits<double>::quiet_NaN());
M128D const zero(0.0);

// Argument reduction.
M128D const mantissa_reduce_shifter(
    static_cast<double>(1LL << (std::numeric_limits<double>::digits - 1)));
M128D const two_over_œÄ(2.0 / œÄ);
M128D const C‚ÇÅ(internal::C‚ÇÅ);
M128D const Œ¥C‚ÇÅ(internal::Œ¥C‚ÇÅ);
M128D const C‚ÇÇ(internal::C‚ÇÇ);
M128D const C π‚ÇÇ(internal::C π‚ÇÇ);
M128D const Œ¥C‚ÇÇ(internal::Œ¥C‚ÇÇ);

// Accurate table index.
M128D const mantissa_index_bits = M128D::MakeFromBits(0x0000'0000'0000'01ffull);
M128D const accurate_table_index_addend(static_cast<double>(
    1LL << (std::numeric_limits<double>::digits - table_spacing_bits - 1)));

// Polynomials.
M128D const sin_0(-0x1.5555'5555'5555'5p-3);
M128D const sin_1(0x1.1111'10A8'20AE'Cp-7);
M128D const sin_near_zero_0(-0x1.5555'5555'5555'5p-3);
M128D const sin_near_zero_1(0x1.1111'10B4'0E88'Ap-7);
M128D const cos_0(-0x1.FFFF'FFFF'FFFF'Dp-2);
M128D const cos_1(0x1.5555'549D'B0A9'5p-5);

}  // namespace m128d

template<FMAPresence fma_presence>
M128D MaybeFusedMultiplyAdd(M128D const a, M128D const b, M128D const c) {
  static_assert(fma_presence != FMAPresence::Unknown);
  if constexpr (fma_presence == FMAPresence::Present) {
    return FusedMultiplyAdd(a, b, c);
  } else {
    return a * b + c;
  }
}

template<FMAPresence fma_presence>
M128D MaybeFusedNegatedMultiplyAdd(M128D const a, M128D const b, M128D const c) {
  static_assert(fma_presence != FMAPresence::Unknown);
  if constexpr (fma_presence == FMAPresence::Present) {
    return FusedNegatedMultiplyAdd(a, b, c);
  } else {
    return c - a * b;
  }
}

// See [SZ05], section 2.1 for the validity of this function.
template<FMAPresence fma_presence>
DoublePrecision<M128D> TwoProductAdd(M128D const a,
                                     M128D const b,
                                     M128D const c) {
  static_assert(fma_presence != FMAPresence::Unknown);
  // Somehow `if constexpr` loses a cycle on MSVC 17.
  if (fma_presence == FMAPresence::Present) {
    DoublePrecision<M128D> result(uninitialized);
    result.value = FusedMultiplyAdd(a, b, c);
    result.error = FusedMultiplySubtract(a, b, result.value - c);
    return result;
  } else {
    auto result = VeltkampDekkerProduct(a, b);
    result += c;
    return result;
  }
}

// See [SZ05], section 2.1 for the validity of this function.
template<FMAPresence fma_presence>
DoublePrecision<M128D> TwoProductNegatedAdd(M128D const a,
                                            M128D const b,
                                            M128D const c) {
  static_assert(fma_presence != FMAPresence::Unknown);
  // Somehow `if constexpr` loses a cycle on MSVC 17.
  if (fma_presence == FMAPresence::Present) {
    DoublePrecision<M128D> result(uninitialized);
    result.value = FusedNegatedMultiplyAdd(a, b, c);
    result.error = FusedNegatedMultiplySubtract(a, b, result.value - c);
    return result;
  } else {
    auto result = VeltkampDekkerProduct(-a, b);
    result += c;
    return result;
  }
}

inline std::int64_t AccurateTableIndex(Argument const abs_x) {
  // This function computes the index in the accurate table:
  // 1. A suitable (large) power of 2 is added to the argument so that the last
  //    bit of the mantissa of the result corresponds to units of 1/512 of the
  //    argument.  As part of this addition, an interval of radius 1/1024 around
  //    an integral multiple of 1/512 is correctly rounded to that integral
  //    multiple.
  // 2. An `and` operation is used to only retain the last 9 bits of the
  //    mantissa.
  // 3. The result is interpreted as an integer and returned as the index.
  return (m128d::mantissa_index_bits &
          (abs_x + m128d::accurate_table_index_addend))
      .Bits<std::int64_t>();
}

// Evaluates the sum `y + Œ¥y` and performs the rounding test using the technique
// described in [Mul+10], section 11.6.3.  If rounding is safe, returns the sum;
// otherwise, returns `NaN`.  `y` is always positive.  `Œ¥y` may be positive or
// negative.
template<FMAPresence fma_presence, double e>
Value DetectDangerousRounding(Value const y, Value const Œ¥y) {
  // We don't check that `Œ¥y` is not NaN because that's how we trigger fallback
  // to the slow path.
  DCHECK(y == y);
  DoublePrecision<M128D> const sum = QuickTwoSum(y, Œ¥y);
  auto const& value = sum.value;
  auto const& error = sum.error;
  auto const muller_test_expression =
      MaybeFusedMultiplyAdd<fma_presence>(error, M128D(e), value);
  OSACA_IF(value == muller_test_expression) {
    return value;
  } else {
#if _DEBUG
    LOG_IF(ERROR, value == value && error == error)
        << std::setprecision(25) << y << " " << std::hexfloat << value << " "
        << error << " " << e;
#endif
    return m128d::quiet_NaN;
  }
}

template<FMAPresence fma_presence, bool preserve_sign>
FORCE_INLINE(inline)
void Reduce(Argument const x,
            DoublePrecision<Argument>& x_reduced,
            std::int64_t& quadrant) {
  Argument const abs_x = Abs(x);
  OSACA_IF(abs_x < œÄ / 4) {
    x_reduced.value = x;
    x_reduced.error = m128d::zero;
    quadrant = 0;
    return;
  } OSACA_ELSE_IF(abs_x <= two_term_x_threshold) {
    // We are not very sensitive to rounding errors in this expression, because
    // in the worst case it could cause the reduced angle to jump from the
    // vicinity of œÄ / 4 to the vicinity of -œÄ / 4 with appropriate adjustment
    // of the quadrant.
    M128D const sign = Sign(x);
    M128D n_double =
        MaybeFusedMultiplyAdd<fma_presence>(
            abs_x, m128d::two_over_œÄ, m128d::mantissa_reduce_shifter) -
        m128d::mantissa_reduce_shifter;

    // Don't move the computation of `n` after the if, it generates some extra
    // moves.
    Argument y;
    std::int64_t n;
    if constexpr (preserve_sign) {
      n_double = n_double ^ sign;
      n = _mm_cvtsd_si64(static_cast<__m128d>(n_double));
      y = MaybeFusedNegatedMultiplyAdd<fma_presence>(n_double, m128d::C‚ÇÅ, x);
    } else {
      n = _mm_cvtsd_si64(static_cast<__m128d>(n_double));
      y = MaybeFusedNegatedMultiplyAdd<fma_presence>(n_double, m128d::C‚ÇÅ, abs_x);
    }

    Argument const Œ¥y = n_double * m128d::Œ¥C‚ÇÅ;
    x_reduced = TwoDifference(y, Œ¥y);
    Argument const abs_x_reduced_value = Abs(x_reduced.value);
    OSACA_IF(abs_x_reduced_value >= two_term_x_reduced_threshold) {
      quadrant = n & 0b11;
      return;
    }
  } OSACA_ELSE_IF(abs_x <= three_term_x_threshold) {
    // Same code as above.
    M128D const sign = Sign(x);
    M128D n_double =
        MaybeFusedMultiplyAdd<fma_presence>(
            abs_x, m128d::two_over_œÄ, m128d::mantissa_reduce_shifter) -
        m128d::mantissa_reduce_shifter;

    Argument y;
    std::int64_t n;
    if constexpr (preserve_sign) {
      n_double = n_double ^ sign;
      n = _mm_cvtsd_si64(static_cast<__m128d>(n_double));
      y = MaybeFusedNegatedMultiplyAdd<fma_presence>(n_double, m128d::C‚ÇÇ, x);
    } else {
      n = _mm_cvtsd_si64(static_cast<__m128d>(n_double));
      y = MaybeFusedNegatedMultiplyAdd<fma_presence>(n_double, m128d::C‚ÇÇ, abs_x);
    }

    Argument const y π = n_double * m128d::C π‚ÇÇ;
    Argument const Œ¥y = n_double * m128d::Œ¥C‚ÇÇ;
    auto const z = QuickTwoSum(y π, Œ¥y);
    x_reduced = y - z;
    Argument const abs_x_reduced_value = Abs(x_reduced.value);
    OSACA_IF(abs_x_reduced_value >= three_term_x_reduced_threshold) {
      quadrant = n & 0b11;
      return;
    }
  }
  x_reduced.value = m128d::zero;
  x_reduced.error = m128d::quiet_NaN;
}

template<FMAPresence fma_presence>
Value SinPolynomial(Argument const x) {
  using Polynomial1 =
      HornerEvaluator<Value, Argument, 1, FMAPolicy::Auto, fma_presence>;
  return Polynomial1::Evaluate({m128d::sin_0, m128d::sin_1}, x);
}

template<FMAPresence fma_presence>
Value SinPolynomialNearZero(Argument const x) {
  using Polynomial1 =
      HornerEvaluator<Value, Argument, 1, FMAPolicy::Auto, fma_presence>;
  return Polynomial1::Evaluate(
      {m128d::sin_near_zero_0, m128d::sin_near_zero_1}, x);
}

template<FMAPresence fma_presence>
Value CosPolynomial(Argument const x) {
  using Polynomial1 =
      HornerEvaluator<Value, Argument, 1, FMAPolicy::Auto, fma_presence>;
  return Polynomial1::Evaluate({m128d::cos_0, m128d::cos_1}, x);
}

template<FMAPresence fma_presence>
FORCE_INLINE(inline)
Value SinImplementation(DoublePrecision<Argument> const x_reduced) {
  auto const xÃÉ = x_reduced.value;
  auto const Œ¥xÃÉ = x_reduced.error;
  auto const abs_xÃÉ = Abs(xÃÉ);
  OSACA_IF(abs_xÃÉ < sin_near_zero_cutoff) {
    auto const xÃÉ¬≤ = xÃÉ * xÃÉ;
    auto const xÃÉ¬≥ = xÃÉ¬≤ * xÃÉ;
    auto const xÃÉ¬≥_term = MaybeFusedMultiplyAdd<fma_presence>(
        xÃÉ¬≥, SinPolynomialNearZero<fma_presence>(xÃÉ¬≤), Œ¥xÃÉ);
    return DetectDangerousRounding<fma_presence, sin_near_zero_e>(
        xÃÉ, xÃÉ¬≥_term);
  } else {
    auto const sign = Sign(xÃÉ);
    auto const k = AccurateTableIndex(abs_xÃÉ);
    auto const& accurate_values = SinCosAccurateTable[k];
    M128D const x‚Çñ(accurate_values.x);
    M128D const sin_x‚Çñ(accurate_values.sin_x);
    M128D const cos_x‚Çñ(accurate_values.cos_x);
    // [GB91] incorporates `Œ¥xÃÉ` in the computation of `h`.  However, `xÃÉ` and
    // `Œ¥xÃÉ` don't overlap and in the first interval `xÃÉ` and `h` may be of the
    // same order of magnitude.  Instead we incorporate the terms in `Œ¥xÃÉ` and
    // `Œ¥xÃÉ * h` later in the computation.  Note that the terms in `Œ¥xÃÉ * h¬≤` and
    // higher are *not* computed because they don't matter.
    auto const h = abs_xÃÉ - x‚Çñ;

    // The sign of the argument must be applied to the result.  It's best to do
    // this by applying it to elements of the computation that are available
    // early.
    M128D const signed_sin_x‚Çñ = sign ^ sin_x‚Çñ;
    M128D const signed_cos_x‚Çñ = sign ^ cos_x‚Çñ;
    M128D const signed_Œ¥xÃÉ = sign ^ Œ¥xÃÉ;

    DoublePrecision<M128D> const sin_x‚Çñ_plus_h_cos_x‚Çñ =
        TwoProductAdd<fma_presence>(signed_cos_x‚Çñ, h, signed_sin_x‚Çñ);
    auto const h¬≤ = h * h;
    auto const h¬≥ = h¬≤ * h;
    auto const h_plus_Œ¥xÃÉ¬≤ = h * ((signed_Œ¥xÃÉ + signed_Œ¥xÃÉ) + h);
    auto const polynomial_term =
        MaybeFusedMultiplyAdd<fma_presence>(
            signed_cos_x‚Çñ,
            MaybeFusedMultiplyAdd<fma_presence>(
                h¬≥, SinPolynomial<fma_presence>(h¬≤), signed_Œ¥xÃÉ),
            (signed_sin_x‚Çñ * h_plus_Œ¥xÃÉ¬≤) * CosPolynomial<fma_presence>(h¬≤)) +
        sin_x‚Çñ_plus_h_cos_x‚Çñ.error;
    return DetectDangerousRounding<fma_presence, sin_e>(
        sin_x‚Çñ_plus_h_cos_x‚Çñ.value, polynomial_term);
  }
}

template<FMAPresence fma_presence>
FORCE_INLINE(inline)
Value CosImplementation(DoublePrecision<Argument> const x_reduced) {
  auto const xÃÉ = x_reduced.value;
  auto const Œ¥xÃÉ = x_reduced.error;
  auto const abs_xÃÉ = Abs(xÃÉ);
  auto const sign = Sign(xÃÉ);
  auto const signed_Œ¥xÃÉ = sign ^ Œ¥xÃÉ;
  auto const k = AccurateTableIndex(abs_xÃÉ);
  auto const& accurate_values = SinCosAccurateTable[k];
  M128D const x‚Çñ(accurate_values.x);
  M128D const sin_x‚Çñ(accurate_values.sin_x);
  M128D const cos_x‚Çñ(accurate_values.cos_x);
  // [GB91] incorporates `Œ¥xÃÉ` in the computation of `h`.  However, `xÃÉ` and `Œ¥xÃÉ`
  // don't overlap and in the first interval `xÃÉ` and `h` may be of the same
  // order of magnitude.  Instead we incorporate the terms in `Œ¥xÃÉ` and `Œ¥xÃÉ * h`
  // later in the computation.  Note that the terms in `Œ¥xÃÉ * h¬≤` and higher are
  // *not* computed because they don't matter.
  auto const h = abs_xÃÉ - x‚Çñ;

  DoublePrecision<M128D> const cos_x‚Çñ_minus_h_sin_x‚Çñ =
      TwoProductNegatedAdd<fma_presence>(sin_x‚Çñ, h, cos_x‚Çñ);
  auto const h¬≤ = h * h;
  auto const h¬≥ = h¬≤ * h;
  auto const h_plus_Œ¥xÃÉ¬≤ = h * ((signed_Œ¥xÃÉ + signed_Œ¥xÃÉ) + h);
  auto const polynomial_term =
      MaybeFusedNegatedMultiplyAdd<fma_presence>(
          sin_x‚Çñ,
          MaybeFusedMultiplyAdd<fma_presence>(
              h¬≥, SinPolynomial<fma_presence>(h¬≤), signed_Œ¥xÃÉ),
          (cos_x‚Çñ * h_plus_Œ¥xÃÉ¬≤) * CosPolynomial<fma_presence>(h¬≤)) +
      cos_x‚Çñ_minus_h_sin_x‚Çñ.error;
  return DetectDangerousRounding<fma_presence, cos_e>(
      cos_x‚Çñ_minus_h_sin_x‚Çñ.value, polynomial_term);
}

template<FMAPresence fma_presence>
FORCE_INLINE(inline)
SC<Value> SinCosImplementation(DoublePrecision<Argument> const x_reduced) {
  SC<Value> m128ds;
  auto const xÃÉ = x_reduced.value;
  auto const Œ¥xÃÉ = x_reduced.error;
  auto const abs_xÃÉ = Abs(xÃÉ);
  auto const sign = Sign(xÃÉ);
  auto const k = AccurateTableIndex(abs_xÃÉ);
  auto const& accurate_values = SinCosAccurateTable[k];
  M128D const x‚Çñ(accurate_values.x);
  M128D const sin_x‚Çñ(accurate_values.sin_x);
  M128D const cos_x‚Çñ(accurate_values.cos_x);
  // [GB91] incorporates `Œ¥xÃÉ` in the computation of `h`.  However, `xÃÉ` and `Œ¥xÃÉ`
  // don't overlap and in the first interval `xÃÉ` and `h` may be of the same
  // order of magnitude.  Instead we incorporate the terms in `Œ¥xÃÉ` and `Œ¥xÃÉ * h`
  // later in the computation.  Note that the terms in `Œ¥xÃÉ * h¬≤` and higher are
  // *not* computed because they don't matter.
  auto const h = abs_xÃÉ - x‚Çñ;

  // The sign of the argument must be applied to the result.  It's best to do
  // this by applying it to elements of the computation that are available
  // early.
  M128D const signed_sin_x‚Çñ = sign ^ sin_x‚Çñ;
  M128D const signed_cos_x‚Çñ = sign ^ cos_x‚Çñ;
  M128D const signed_Œ¥xÃÉ = sign ^ Œ¥xÃÉ;

  DoublePrecision<M128D> const sin_x‚Çñ_plus_h_cos_x‚Çñ =
      TwoProductAdd<fma_presence>(signed_cos_x‚Çñ, h, signed_sin_x‚Çñ);
  DoublePrecision<M128D> const cos_x‚Çñ_minus_h_sin_x‚Çñ =
      TwoProductNegatedAdd<fma_presence>(sin_x‚Çñ, h, cos_x‚Çñ);
  auto const h¬≤ = h * h;
  auto const h¬≥ = h¬≤ * h;
  auto const h_plus_Œ¥xÃÉ¬≤ = h * ((signed_Œ¥xÃÉ + signed_Œ¥xÃÉ) + h);

  auto const h¬≥_sin_polynomial = MaybeFusedMultiplyAdd<fma_presence>(
      h¬≥, SinPolynomial<fma_presence>(h¬≤), signed_Œ¥xÃÉ);
  auto const h_plus_e¬≤_cos_polynomial =
      h_plus_Œ¥xÃÉ¬≤ * CosPolynomial<fma_presence>(h¬≤);

  auto const sin_polynomial_term =
      MaybeFusedMultiplyAdd<fma_presence>(
          signed_cos_x‚Çñ,
          h¬≥_sin_polynomial,
          signed_sin_x‚Çñ * h_plus_e¬≤_cos_polynomial) +
      sin_x‚Çñ_plus_h_cos_x‚Çñ.error;
  auto const cos_polynomial_term =
      MaybeFusedNegatedMultiplyAdd<fma_presence>(
          sin_x‚Çñ,
          h¬≥_sin_polynomial,
          cos_x‚Çñ * h_plus_e¬≤_cos_polynomial) +
      cos_x‚Çñ_minus_h_sin_x‚Çñ.error;
  m128ds.cos = DetectDangerousRounding<fma_presence, cos_e>(
      cos_x‚Çñ_minus_h_sin_x‚Çñ.value, cos_polynomial_term);
  OSACA_IF(abs_xÃÉ < sin_near_zero_cutoff) {
    auto const xÃÉ¬≤ = xÃÉ * xÃÉ;
    auto const xÃÉ¬≥ = xÃÉ¬≤ * xÃÉ;
    auto const xÃÉ¬≥_term = MaybeFusedMultiplyAdd<fma_presence>(
        xÃÉ¬≥, SinPolynomialNearZero<fma_presence>(xÃÉ¬≤), Œ¥xÃÉ);
    m128ds.sin =
        DetectDangerousRounding<fma_presence, sin_near_zero_e>(xÃÉ, xÃÉ¬≥_term);
  } else {
    m128ds.sin = DetectDangerousRounding<fma_presence, sin_e>(
        sin_x‚Çñ_plus_h_cos_x‚Çñ.value, sin_polynomial_term);
  }
  return m128ds;
}

template<FMAPresence fma_presence>
double __cdecl Sin(double x) {
  OSACA_FUNCTION_BEGIN(x, <fma_presence>);
  DoublePrecision<Argument> x_reduced;
  std::int64_t quadrant;
  double value;
  Reduce<fma_presence, /*preserve_sign=*/true>(
      M128D(x), x_reduced, quadrant);
  OSACA_IF(quadrant & 0b1) {
    value = static_cast<double>(CosImplementation<fma_presence>(x_reduced));
  } else {
    value = static_cast<double>(SinImplementation<fma_presence>(x_reduced));
  }
  OSACA_IF(value != value) {
    if (slow_path_sin_callback != nullptr) {
      slow_path_sin_callback(x);
    }
    OSACA_RETURN(cr_sin(x));
  } OSACA_ELSE_IF(quadrant & 0b10) {
    OSACA_RETURN(-value);
  } else {
    OSACA_RETURN(value);
  }
}

template<FMAPresence fma_presence>
double __cdecl Cos(double x) {
  OSACA_FUNCTION_BEGIN(x, <fma_presence>);
  DoublePrecision<Argument> x_reduced;
  std::int64_t quadrant;
  double value;
  Reduce<fma_presence, /*preserve_sign=*/false>(
      M128D(x), x_reduced, quadrant);
  OSACA_IF(quadrant & 0b1) {
    value = static_cast<double>(SinImplementation<fma_presence>(x_reduced));
  } else {
    value = static_cast<double>(CosImplementation<fma_presence>(x_reduced));
  }
  OSACA_IF(value != value) {
    if (slow_path_cos_callback != nullptr) {
      slow_path_cos_callback(x);
    }
    OSACA_RETURN(cr_cos(x));
  } OSACA_ELSE_IF(quadrant == 1 || quadrant == 2) {
    OSACA_RETURN(-value);
  } else {
    OSACA_RETURN(value);
  }
}

template<FMAPresence fma_presence>
SC<double> __cdecl SinCos(double x) {
  OSACA_FUNCTION_BEGIN(x, <fma_presence>);
  SC<double> values;
  DoublePrecision<Argument> x_reduced;
  std::int64_t quadrant;
  Reduce<fma_presence, /*preserve_sign=*/true>(
      M128D(x), x_reduced, quadrant);
  auto m128ds = SinCosImplementation<fma_presence>(x_reduced);
  OSACA_IF(quadrant & 0b1) {
    values.sin = static_cast<double>(m128ds.cos);
    values.cos = static_cast<double>(m128ds.sin);
  } else {
    values.sin = static_cast<double>(m128ds.sin);
    values.cos = static_cast<double>(m128ds.cos);
  }
  OSACA_IF(values.sin != values.sin || values.cos != values.cos) {
    if (slow_path_sin_callback != nullptr) {
      slow_path_sin_callback(x);
    }
    if (slow_path_cos_callback != nullptr) {
      slow_path_cos_callback(x);
    }
    OSACA_RETURN((SC<double>{.sin = cr_sin(x), .cos = cr_cos(x)}));
  }
  OSACA_IF(quadrant & 0b10) {
    values.sin = -values.sin;
  }
  OSACA_IF(quadrant == 1 || quadrant == 2) {
    values.cos = -values.cos;
  }
  OSACA_RETURN(values);
}

void SetSlowPathsCallbacks(SlowPathCallback sin_cb, SlowPathCallback cos_cb) {
  slow_path_sin_callback = std::move(sin_cb);
  slow_path_cos_callback = std::move(cos_cb);
}

template double __cdecl Sin<FMAPresence::Absent>(double x);
template double __cdecl Sin<FMAPresence::Present>(double x);
template double __cdecl Cos<FMAPresence::Absent>(double x);
template double __cdecl Cos<FMAPresence::Present>(double x);
template SC<double> __cdecl SinCos<FMAPresence::Absent>(double x);
template SC<double> __cdecl SinCos<FMAPresence::Present>(double x);

}  // namespace internal
}  // namespace _sin_cos
}  // namespace numerics
}  // namespace principia
